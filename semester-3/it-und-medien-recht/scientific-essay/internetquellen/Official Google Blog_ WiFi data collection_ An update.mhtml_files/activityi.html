<!DOCTYPE html>
<!-- saved from url=(0029)chrome-error://chromewebdata/ -->
<html dir="ltr" lang="en" subframe=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="theme-color" content="#fff">
  <meta name="viewport" content="width=device-width, initial-scale=1.0,
                                 maximum-scale=1.0, user-scalable=no">
  <title>2542116.fls.doubleclick.net</title>
  <style>/* Copyright 2017 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file. */

a {
  color: var(--link-color);
}

body {
  --background-color: #fff;
  --error-code-color: var(--google-gray-700);
  --google-blue-100: rgb(210, 227, 252);
  --google-blue-300: rgb(138, 180, 248);
  --google-blue-600: rgb(26, 115, 232);
  --google-blue-700: rgb(25, 103, 210);
  --google-gray-100: rgb(241, 243, 244);
  --google-gray-300: rgb(218, 220, 224);
  --google-gray-500: rgb(154, 160, 166);
  --google-gray-50: rgb(248, 249, 250);
  --google-gray-600: rgb(128, 134, 139);
  --google-gray-700: rgb(95, 99, 104);
  --google-gray-800: rgb(60, 64, 67);
  --google-gray-900: rgb(32, 33, 36);
  --heading-color: var(--google-gray-900);
  --link-color: rgb(88, 88, 88);
  --popup-container-background-color: rgba(0,0,0,.65);
  --primary-button-fill-color-active: var(--google-blue-700);
  --primary-button-fill-color: var(--google-blue-600);
  --primary-button-text-color: #fff;
  --quiet-background-color: rgb(247, 247, 247);
  --secondary-button-border-color: var(--google-gray-500);
  --secondary-button-fill-color: #fff;
  --secondary-button-hover-border-color: var(--google-gray-600);
  --secondary-button-hover-fill-color: var(--google-gray-50);
  --secondary-button-text-color: var(--google-gray-700);
  --small-link-color: var(--google-gray-700);
  --text-color: var(--google-gray-700);
  background: var(--background-color);
  color: var(--text-color);
  word-wrap: break-word;
}

.nav-wrapper .secondary-button {
  background: var(--secondary-button-fill-color);
  border: 1px solid var(--secondary-button-border-color);
  color: var(--secondary-button-text-color);
  float: none;
  margin: 0;
  padding: 8px 16px;
}

.hidden {
  display: none;
}

html {
  -webkit-text-size-adjust: 100%;
  font-size: 125%;
}

.icon {
  background-repeat: no-repeat;
  background-size: 100%;
}

@media (prefers-color-scheme: dark) {
  body {
    --background-color: var(--google-gray-900);
    --error-code-color: var(--google-gray-500);
    --heading-color: var(--google-gray-500);
    --link-color: var(--google-blue-300);
    --primary-button-fill-color-active: rgb(129, 162, 208);
    --primary-button-fill-color: var(--google-blue-300);
    --primary-button-text-color: var(--google-gray-900);
    --quiet-background-color: var(--background-color);
    --secondary-button-border-color: var(--google-gray-700);
    --secondary-button-fill-color: var(--google-gray-900);
    --secondary-button-hover-fill-color: rgb(48, 51, 57);
    --secondary-button-text-color: var(--google-blue-300);
    --small-link-color: var(--google-blue-300);
    --text-color: var(--google-gray-500);
  }
}
</style>
  <style>/* Copyright 2014 The Chromium Authors. All rights reserved.
   Use of this source code is governed by a BSD-style license that can be
   found in the LICENSE file. */

button {
  border: 0;
  border-radius: 4px;
  box-sizing: border-box;
  color: var(--primary-button-text-color);
  cursor: pointer;
  float: right;
  font-size: .875em;
  margin: 0;
  padding: 8px 16px;
  transition: box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1);
  user-select: none;
}

[dir='rtl'] button {
  float: left;
}

.bad-clock button,
.captive-portal button,
.insecure-form button,
.lookalike-url button,
.main-frame-blocked button,
.neterror button,
.offline button,
.pdf button,
.ssl button,
.safe-browsing-billing button {
  background: #656565;
}

button:active {
  background: #333333;
  outline: 0;
}

#debugging {
  display: inline;
  overflow: auto;
}

.debugging-content {
  line-height: 1em;
  margin-bottom: 0;
  margin-top: 1em;
}

.debugging-content-fixed-width {
  display: block;
  font-family: monospace;
  font-size: 1.2em;
  margin-top: 0.5em;
}

.debugging-title {
  font-weight: bold;
}

#details {
  margin: 0 0 50px;
}

#details p:not(:first-of-type) {
  margin-top: 20px;
}

.secondary-button:active {
  border-color: white;
  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3),
      0 2px 6px 2px rgba(60, 64, 67, .15);
}

.secondary-button:hover {
  background: var(--secondary-button-hover-fill-color);
  border-color: var(--secondary-button-hover-border-color);
  text-decoration: none;
}

.error-code {
  color: var(--error-code-color);
  font-size: .86667em;
  text-transform: uppercase;
  margin-top: 12px;
}

#error-debugging-info {
  font-size: 0.8em;
}

h1 {
  color: var(--heading-color);
  font-size: 1.6em;
  font-weight: normal;
  line-height: 1.25em;
  margin-bottom: 16px;
}

h2 {
  font-size: 1.2em;
  font-weight: normal;
}

.icon {
  height: 72px;
  margin: 0 0 40px;
  width: 72px;
}

input[type=checkbox] {
  opacity: 0;
}

input[type=checkbox]:focus ~ .checkbox:after {
  outline: -webkit-focus-ring-color auto 5px;
}

.interstitial-wrapper {
  box-sizing: border-box;
  font-size: 1em;
  line-height: 1.6em;
  margin: 14vh auto 0;
  max-width: 600px;
  width: 100%;
}

#main-message > p {
  display: inline;
}

#extended-reporting-opt-in {
  font-size: .875em;
  margin-top: 32px;
}

#extended-reporting-opt-in label {
  display: grid;
  grid-template-columns: 1.8em 1fr;
  position: relative;
}

#enhanced-protection-message {
  border-radius: 4px;
  font-size: 1em;
  margin-top: 32px;
  padding: 10px 5px;
}

#enhanced-protection-message label {
  display: grid;
  grid-template-columns: 2.5em 1fr;
  position: relative;
}

#enhanced-protection-message div {
  margin: 0.5em;
}

#enhanced-protection-message .icon {
  height: 1.5em;
  vertical-align: middle;
  width: 1.5em;
}

.nav-wrapper {
  margin-top: 51px;
}

.nav-wrapper::after {
  clear: both;
  content: '';
  display: table;
  width: 100%;
}

.small-link {
  color: var(--small-link-color);
  font-size: .875em;
}

.checkboxes {
  flex: 0 0 24px;
}

.checkbox {
  --padding: .9em;
  background: transparent;
  display: block;
  height: 1em;
  left: -1em;
  padding-inline-start: var(--padding);
  position: absolute;
  right: 0;
  top: -.5em;
  width: 1em;
}

.checkbox::after {
  border: 1px solid white;
  border-radius: 2px;
  content: '';
  height: 1em;
  position: absolute;
  top: var(--padding);
  left: var(--padding);
  width: 1em;
}

.checkbox::before {
  background: transparent;
  border: 2px solid white;
  border-right-width: 0;
  border-top-width: 0;
  content: '';
  height: .2em;
  left: calc(.3em + var(--padding));
  opacity: 0;
  position: absolute;
  top: calc(.3em  + var(--padding));
  transform: rotate(-45deg);
  width: .5em;
}

input[type=checkbox]:checked ~ .checkbox::before {
  opacity: 1;
}

#recurrent-error-message {
  background: #ededed;
  border-radius: 4px;
  padding: 12px 16px;
  margin-top: 12px;
  margin-bottom: 16px;
}

.showing-recurrent-error-message #extended-reporting-opt-in {
  margin-top: 16px;
}

.showing-recurrent-error-message #enhanced-protection-message {
  margin-top: 16px;
}

@media (max-width: 700px) {
  .interstitial-wrapper {
    padding: 0 10%;
  }

  #error-debugging-info {
    overflow: auto;
  }
}

@media (max-width: 420px) {
  button,
  [dir='rtl'] button,
  .small-link {
    float: none;
    font-size: .825em;
    font-weight: 500;
    margin: 0;
    width: 100%;
  }

  button {
    padding: 16px 24px;
  }

  #details {
    margin: 20px 0 20px 0;
  }

  #details p:not(:first-of-type) {
    margin-top: 10px;
  }

  .secondary-button:not(.hidden) {
    display: block;
    margin-top: 20px;
    text-align: center;
    width: 100%;
  }

  .interstitial-wrapper {
    padding: 0 5%;
  }

  #extended-reporting-opt-in {
    margin-top: 24px;
  }

  #enhanced-protection-message {
    margin-top: 24px;
  }

  .nav-wrapper {
    margin-top: 30px;
  }
}

/**
 * Mobile specific styling.
 * Navigation buttons are anchored to the bottom of the screen.
 * Details message replaces the top content in its own scrollable area.
 */

@media (max-width: 420px) {
  .nav-wrapper .secondary-button {
    border: 0;
    margin: 16px 0 0;
    margin-inline-end: 0;
    padding-bottom: 16px;
    padding-top: 16px;
  }
}

/* Fixed nav. */
@media (min-width: 240px) and (max-width: 420px) and
       (min-height: 401px),
       (min-width: 421px) and (min-height: 240px) and
       (max-height: 560px) {
  body .nav-wrapper {
    background: var(--background-color);
    bottom: 0;
    box-shadow: 0 -12px 24px var(--background-color);
    left: 0;
    margin: 0 auto;
    max-width: 736px;
    padding-left: 24px;
    padding-right: 24px;
    position: fixed;
    right: 0;
    width: 100%;
    z-index: 2;
  }

  .interstitial-wrapper {
    max-width: 736px;
  }

  #details,
  #main-content {
    padding-bottom: 40px;
  }

  #details {
    padding-top: 5.5vh;
  }

  button.small-link {
    color: var(--google-blue-600);
  }
}

@media (max-width: 420px) and (orientation: portrait),
       (max-height: 560px) {
  body {
    margin: 0 auto;
  }

  button,
  [dir='rtl'] button,
  button.small-link,
  .nav-wrapper .secondary-button {
    font-family: Roboto-Regular,Helvetica;
    font-size: .933em;
    margin: 6px 0;
    transform: translatez(0);
  }

  .nav-wrapper {
    box-sizing: border-box;
    padding-bottom: 8px;
    width: 100%;
  }

  #details {
    box-sizing: border-box;
    height: auto;
    margin: 0;
    opacity: 1;
    transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);
  }

  #details.hidden,
  #main-content.hidden {
    display: block;
    height: 0;
    opacity: 0;
    overflow: hidden;
    padding-bottom: 0;
    transition: none;
  }

  h1 {
    font-size: 1.5em;
    margin-bottom: 8px;
  }

  .icon {
    margin-bottom: 5.69vh;
  }

  .interstitial-wrapper {
    box-sizing: border-box;
    margin: 7vh auto 12px;
    padding: 0 24px;
    position: relative;
  }

  .interstitial-wrapper p {
    font-size: .95em;
    line-height: 1.61em;
    margin-top: 8px;
  }

  #main-content {
    margin: 0;
    transition: opacity 100ms cubic-bezier(0.4, 0, 0.2, 1);
  }

  .small-link {
    border: 0;
  }

  .suggested-left > #control-buttons,
  .suggested-right > #control-buttons {
    float: none;
    margin: 0;
  }
}

@media (min-width: 421px) and (min-height: 500px) and (max-height: 560px) {
  .interstitial-wrapper {
    margin-top: 10vh;
  }
}

@media (min-height: 400px) and (orientation:portrait) {
  .interstitial-wrapper {
    margin-bottom: 145px;
  }
}

@media (min-height: 299px) {
  .nav-wrapper {
    padding-bottom: 16px;
  }
}

@media (max-height: 560px) and (min-height: 240px) and (orientation:landscape) {
  .extended-reporting-has-checkbox #details {
    padding-bottom: 80px;
  }
}

@media (min-height: 500px) and (max-height: 650px) and (max-width: 414px) and
       (orientation: portrait) {
  .interstitial-wrapper {
    margin-top: 7vh;
  }
}

@media (min-height: 650px) and (max-width: 414px) and (orientation: portrait) {
  .interstitial-wrapper {
    margin-top: 10vh;
  }
}

/* Small mobile screens. No fixed nav. */
@media (max-height: 400px) and (orientation: portrait),
       (max-height: 239px) and (orientation: landscape),
       (max-width: 419px) and (max-height: 399px) {
  .interstitial-wrapper {
    display: flex;
    flex-direction: column;
    margin-bottom: 0;
  }

  #details {
    flex: 1 1 auto;
    order: 0;
  }

  #main-content {
    flex: 1 1 auto;
    order: 0;
  }

  .nav-wrapper {
    flex: 0 1 auto;
    margin-top: 8px;
    order: 1;
    padding-left: 0;
    padding-right: 0;
    position: relative;
    width: 100%;
  }

  button,
  .nav-wrapper .secondary-button {
    padding: 16px 24px;
  }

  button.small-link {
    color: var(--google-blue-600);
  }
}

@media (max-width: 239px) and (orientation: portrait) {
  .nav-wrapper {
    padding-left: 0;
    padding-right: 0;
  }
}
</style>
  <style>/* Copyright 2013 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file. */

/* Don't use the main frame div when the error is in a subframe. */
html[subframe] #main-frame-error {
  display: none;
}

/* Don't use the subframe error div when the error is in a main frame. */
html:not([subframe]) #sub-frame-error {
  display: none;
}

#diagnose-button {
  float: none;
  margin-bottom: 10px;
  margin-inline-start: 0;
  margin-top: 20px;
}

h1 {
  margin-top: 0;
  word-wrap: break-word;
}

h1 span {
  font-weight: 500;
}

h2 {
  color: var(--heading-color);
  font-size: 1.2em;
  font-weight: normal;
  margin: 10px 0;
}

a {
  text-decoration: none;
}

.icon {
  -webkit-user-select: none;
  display: inline-block;
}

.icon-generic {
  /**
   * Can't access chrome://theme/IDR_ERROR_NETWORK_GENERIC from an untrusted
   * renderer process, so embed the resource manually.
   */
  content: -webkit-image-set(
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAMAAABiM0N1AAABSlBMVEUAAADj4+P/xwDj4+P/xwDn5+fk5OT/xwDk5OTf39//zwD/xwDj4+Pj4+Pk5OT/xgD//wDh4eH/3wDj4+Ph4eH/xADi4uLj4+P/xwDh4eH/wwDj4+P/xwDi4uLf39//yQD/xQD/wwDj4+P/xwD/xgD/xgDj4+Pf39/i4uLm5ubh4eH/zwD/xwD/ygD/xwDk5OTl5eX/xgDf39//yAD/yAD/zwDj4+P/xgD/xAD/yAD/xgDq6uosLCzj4+P////y8vL/xwD+/v7x8fH7+/v9/f34+Pjm5ubl5eX29vbn5+ft7e38/Pz09PT6+vrk5OSwjRBHQCbs7OxGPyY5Ninv7++Ibxnp6enz8/Po6Oj+xgDr6+vXqgh7ZhujgxPyvQOigxNhUyFGQCe9lg5TSSO9lg1uXB5uXR5GQCY6Nik6Nyn19fX5+fnu7u7ltAVVnLrAAAAAO3RSTlMA3/6/3yCfIDAgEO9/gF+gAJAAQHBgUJC/gEDvIaBQf4BBr0CPcG9AsG+gEZ8wz3BP7zAArwDPUDCP7uuCuk4AAAMzSURBVHhe7ZdHe9s4EIbByLLl3hLX2IlLeu/ZRWGnuntP7233/1/DAmkIkCCkUw7xewJpPp8x38xgIPRnOGd49dbgeskwDCoRviqV5hdXy6gHbswbVIsx+FgjUynRHikVbus67YMxpGSM9sWYWqdPLiqSRfumgvLI8bmKzZrrMeb98h2c53huwqgMNj2WwmvVqcwsyrIiy/gsQ02WmkZZDDGoY5aLI1Wmzuq6yxS4YnzZspyjKY48psQ9oSkeIplFjQ7gnRSW0nQqLtDRRjdYUEVVl2lwt2iHmwVCx0yLCSWpzn6dRdhmo9VkEraz20heYsi/Uiiuw2YQrgJBib+stqOlrxc6Sv1HzAQaqZdYKUQ5LRYBu0vBk2ULLimFbBbB0xIohbwtjRCGKCIcqc/gC6wRcsRKqdoMcGkErzJTI+RLXX7AgDjgBl/XNEJtLuTVc/xOHwuuRqgbig+mdWinTfM0QhAHhnrgHCRlz9EKyVuqduq7KagyfWiwgRDoFD+gdJdxNKFBcoWao7vmTxNLf21rhGrZwwJoMMDXCB2LPaGeCI6+RbJ+Q/7kpBrLKqGqnf0aTjzJayNv0MJBm+kusA9o0ZAJNDKiHLQ4O1jBaSCIJ8jQwMBI4VGbLQFIPbRsGf1jWZtKIZw/L5zMhsbRkBVyr8dxhPOGppPMj4FIaAGJrMOAbMolIKe+mTh9yYq5hgRug62BnfH7P0Gn43QiNCr6fZECR4JS6+xM2I8dXSKWy2jS4mwWXGtspqR5QsHphCX1RQuGrEw7oOD0a0LeR34/6f/qZyaFVUmc/kDIp9jvqcwFCQh8lsGPiwGc/kLI19jvOwiYpTK4JVhlm92B33H6kJDDeHF3RipJGez47VDNdmsmhm6ZQC+tmDeEvEtWa+KNXQ84HfGRkM/J6v4zBDygvVFGV6yE/wl5xZdX036PUx3c6Udc6O3OjsUZvYz6UAKnOaen3eXTGaEsS1QDNGvI9v7edvdhbQqlqawYtIjnsdOcb4Tsdx+yh+Xw3OJ8SfVzHZwO+U7IHl/KfusZsoDtnR8Qmui3nklLyQL4reeFVcAS6p2NUOCCgn830N/NOb8B26/tMXzSLIQAAAAASUVORK5CYII=) 1x,
      url(data:image/png;base64,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) 2x);
}

.icon-offline {
  content: -webkit-image-set(
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAMAAABiM0N1AAABSlBMVEUAAADj4+P/xwDj4+P/xwDn5+fk5OT/xwDk5OTf39//zwD/xwDj4+Pj4+Pk5OTi4uL//wDh4eH/3wDj4+Ph4eH/xADi4uLj4+P/xwDh4eH/wwDj4+P/xwD/xgDf39//yQD/xQD/wwDj4+P/xwD/xgD/xgDj4+Pf39/i4uLm5ubh4eH/zwD/xwD/ygD/xwDk5OTl5eX/xgDf39//yAD/yAD/zwDj4+P/xgD/xAD/yAD/xgAsLCzq6urx8fHm5uby8vL8/Pzj4+P/xwD////+/v74+Pj9/f3l5eX29vbn5+ft7e37+/v09PT6+vrk5OSwjRBHQCbs7OxGPyY5Ninv7++Ibxnp6enz8/Po6Oj+xgDr6+vXqgh7ZhujgxPyvQOigxNhUyFGQCe9lg5TSSO9lg1uXB5uXR5GQCY6Nik6Nyn19fX5+fnu7u7ltAWzfMZ2AAAAO3RSTlMA3/6/3yCfIDAgEO9/gF+gAJAAQHBgUJC/gEDvIaBQf4BBr0CPcG9AsG+gEZ8wz3BP7zAArwDPUDCP7uuCuk4AAAMsSURBVHhe7ZdFd90wEEblOi95YWywTRsoM4NkhsdhLjP//20NiseyLMteddHclY6TcyN9M4Kgf8MZg8s3+ldVRVGsDMEnVZ1bWK6VsVybUywpSv9DiaauWiVRC6d11arAiNgzAoLqpuoeYEZQLKsy9VxRTs4NYjQ7vuP4vzyN5CWeWzBOQ4zAAfjdFmeaRjzjWY3ncDSzqknEo7CLOnRy0ViRIou61XEEdNhJ8W05m/YcQDi86Sgtus+JFiQewD8qbKVJ8LTAI11df0EXNSAfkWkjEV0vEB06UgxoSXH1W5HANdpdMytwte12/JFA/YWiqA9NPRjpjIl+bPTCoScXHaT+ImFF7dRHIhRZlG4kgtmloMVymZSEIjcS0bLoQpG/IRERWEWIltlnsF4iEWlspzRcB+hEItplhkTkZXb5HnjiBbfpuCkR9ajIb+XknT4WOhJRshQvCS2hlw7Nl4ggEQL9QNmL255SUgRTapjUYzJWR740mEAA7BRPt6xt8MiWRrNkes7aNn4aJPPTnkTU5A8LoO0AnkR0yO4J8Y2gybcInzfUL1tUZUkkarj8b8OJl8lamUY83EEL7QvxAd1QNIaGhoQHG+EvVkga0KMbZKCvb6jwqOVbAEoPW7aGXtj2ulBE8u8LjZvQKBqwA+6UvI5I3qWpxad1XyiaRyyrcEGabAvwpTfjpM/bEVdY0U2IVXe5vH8zntOkY9Ewm/eMBRwwpu7JCTMfN3xELNXQRZuyLn7WgInHDD00acqi+KGlmyJPT7cg6dcYvw/zflT96WfEjVWPk/6A8aco7wnugQToHq/xomaApL9g/DXK+xYCpq0spMtE5RrJhX+a9D7G+9Hg9hTTkjxE83qBze00DQK7ZQw9tyPeYPwuHq2wL3Y5kHTIR4w/x6O7TxBwr6Sohi7ZMX8wfkWHl9N5j0odNOkHVPR2a8umDF9AFUyQNOX4OBk+nmLaUpVo6GalbO7ubCamlQmUpj6uFHqeRklTvmG8m4j4w3JwdmFOFf27DkkHfMd4hw4h77IM2MDm1g9YGuRdCkiaZx7ylvPMLmCxgmgtEJwT8HIN/d+c8RcO3hkvbtK1IAAAAABJRU5ErkJggg==) 1x,
      url(data:image/png;base64,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) 2x);
  position: relative;
}

.icon-disabled {
  content: -webkit-image-set(
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAABICAMAAAAZF4G5AAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAASZJREFUeAHd11Fq7jAMRGGf/W/6PoWB67YMqv5DybwG/CFjRuR8JBw3+ByiRjgV9W/TJ31P0tBfC6+cj1haUFXKHmVJo5wP98WwQ0ZCbfUc6LQ6VuUBz31ikADkLMkDrfUC4rR6QGW+gF6rx7NaHWCj1Y/W6lf4L7utvgBSt3rBFSS/XBMPUILcJINHCBWYUfpWn4NBi1ZfudIc3rf6/NGEvEA+AsYTJozmXemjXeLZAov+mnkN2HfzXpMSVQDnGw++57qNJ4D1xitA2sJ+VAWMygSEaYf2mYPTjZfk2K8wmP7HLIH5Mg4/pP+PEcDzUvDMvYbs/2NWwPO5vBdMZE4EE5UTQLiBFDaUlTDPBRoJ9HdAYIkIo06og3BNXtCzy7zA1aXk5x+tJARq63eAygAAAABJRU5ErkJggg==) 1x,
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAACQAQMAAAArwfVjAAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAAYdJREFUeF7F1EFqwzAUBNARAmVj0FZe5QoBH6BX+dn4GlY2PYNzGx/A0CvkCIJuvIraKJKbgBvzf2g62weDGD7CYggpfFReis4J0ey9EGFIiEQQojFSlA9kSIiqd0KkFjKsewgRbStEN19mxUPTtmW9HQ/h6tyqNQ8NlSMZdzyE6qkoE0trVYGFm0n1WYeBhduzwbwBC7voS+vIxfeMjeaiLxsMMtQNwMPtuew+DjzcTHk8YMfDknEcIUOtf2lVfgVH3K4Xv5PRYAXRVMtItIJ3rfaCIVn9DsTH2NxisAVRex2Hh3hX+/mRUR08bAwPEYsI51ZxWH4Q0SpicQRXeyEaIug48FEdegARfMz/tADVsRciwTAxW308ehmC2gLraC+YCbV3QoTZexa+zegAEW5PhhgYfmbvJgcRqngGByOSXdFJcLk2JeDPEN0kxe1JhIt5FiFA+w+ItMELsUyPF2IaJ4aILqb4FbxPwhImwj6JauKgDUCYaxmYIsd4KXdMjIC9ItB5Bn4BNRwsG0XM2nwAAAAASUVORK5CYII=) 2x);
  width: 112px;
}

.error-code {
  display: block;
  font-size: .8em;
}

#content-top {
  margin: 20px;
}

#help-box-inner {
  background-color: #f9f9f9;
  border-top: 1px solid #EEE;
  color: #444;
  padding: 20px;
  text-align: start;
}

.hidden {
  display: none;
}

#suggestion {
  margin-top: 15px;
}

#suggestions-list a {
  color: var(--google-blue-600);
}

#suggestions-list p {
  margin-block-end: 0;
}

#suggestions-list ul {
  margin-top: 0;
}

.single-suggestion {
  list-style-type: none;
  padding-left: 0;
}

#short-suggestion {
  margin-top: 5px;
}

#error-information-button {
  content: url((../../../../chromium/components/neterror/resources/images/help_outline.svg);
  height: 24px;
  vertical-align: -.15em;
  width: 24px;
}

.use-popup-container#error-information-popup-container
  #error-information-popup {
  align-items: center;
  background-color: var(--popup-container-background-color);
  display: flex;
  height: 100%;
  left: 0;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 100;
}

.use-popup-container#error-information-popup-container
  #error-information-popup-box {
  background-color: var(--background-color);
  left: 5%;
  position: fixed;
  width: 90%;
  z-index: 101;
}

.use-popup-container#error-information-popup-container
  #error-information-popup-content {
  padding: 0.5em;
}

.use-popup-container#error-information-popup-container
  #error-information-popup-content {
  padding: 0.5em;
}

:not(.use-popup-container)#error-information-popup-container
  #error-information-popup-close {
  display: none;
}

#error-information-popup-close {
  margin-right: 2em;
  text-align: right;
}

.link-button {
  color: rgb(66, 133, 244);
  display: inline-block;
  font-weight: bold;
  text-transform: uppercase;
}

#sub-frame-error-details {

  color: #8F8F8F;

  /* Not done on mobile for performance reasons. */
  text-shadow: 0 1px 0 rgba(255,255,255,0.3);

}

[jscontent=hostName],
[jscontent=failedUrl] {
  overflow-wrap: break-word;
}

#search-container {
  /* Prevents a space between controls. */
  display: flex;
  margin-top: 20px;
}

#search-box {
  border: 1px solid #cdcdcd;
  flex-grow: 1;
  font-size: 1em;
  height: 26px;
  margin-right: 0;
  padding: 1px 9px;
}

#search-box:focus {
  border: 1px solid rgb(93, 154, 255);
  outline: none;
}

#search-button {
  border: none;
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
  box-shadow: none;
  display: flex;
  height: 30px;
  margin: 0;
  padding: 0;
  width: 60px;
}

#search-image {
  content:
      -webkit-image-set(
          url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAQAAAB+HTb/AAAArElEQVR4Xn3NsUoCUBzG0XvB3U0chR4geo5qihpt6gkCx0bXFsMERWj2KWqIanAvmlUUoQapwU6g4l8H5bd9Z/iSPS0hu/RqZqrncBuzLl7U3Rn4cSpQFTeroejJl1Lgs7f4ceDPdeBMXYp86gaONYJkY83AnqHiGk9wHnjk16PKgo5N9BUCkzPf5j6M0PfuVg5MymoetFwoaKAlB26WdXAvJ7u5mezitqtkT//7Sv/u96CaLQAAAABJRU5ErkJggg==) 1x,
          url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAeCAQAAACVzLYUAAABYElEQVR4Xr3VMUuVURzH8XO98jgkGikENkRD0KRGDUVDQy0h2SiC4IuIiktL4AvQt1CDBJUJwo1KXXS6cWdHw7tcjWwoC5Hrx+UZgnNO5CXiO/75jD/+QZf9MzjskVU7DrU1zRv9G9ir5hsA4Nii83+GA9ZI1nI1D6tWAE1TRlQMuuuFDthzMQefgo4nKr+f3dIGDdUUHPYD1ISoMQdgJgUfgqaKEOcxWE/BVTArJBvwC0cGY7gNLgiZNsD1GP4EPVn4EtyLYRuczcJ34HYMP4E7GdajDS7FcB48z8AJ8FmI4TjouBkzZ2yBuRQMlsButIZ+dfDVUBqOaIHvavpLVHXfFmAqv45r9gEHNr3y3hcAfLSgSMPgiiZR+6Z9AMuKNAwqpjUcA2h55pxgAfBWkYRlQ254YMJloaxPHbCkiGCymL5RlLA7GnRDXyuC7uhicLoKdRyaDE5Pl00K//93nABqPgBDK8sfWgAAAABJRU5ErkJggg==) 2x);
  margin: auto;
}

.secondary-button {
  background: #d9d9d9;
  color: #696969;
  margin-inline-end: 16px;
}

.snackbar {
  background: #323232;
  border-radius: 2px;
  bottom: 24px;
  box-sizing: border-box;
  color: #fff;
  font-size: .87em;
  left: 24px;
  max-width: 568px;
  min-width: 288px;
  opacity: 0;
  padding: 16px 24px 12px;
  position: fixed;
  transform: translateY(90px);
  will-change: opacity, transform;
  z-index: 999;
}

.snackbar-show {
  -webkit-animation:
    show-snackbar .25s cubic-bezier(0.0, 0.0, 0.2, 1) forwards,
    hide-snackbar .25s cubic-bezier(0.4, 0.0, 1, 1) forwards 5s;
}

@-webkit-keyframes show-snackbar {
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

@-webkit-keyframes hide-snackbar {
  0% {
    opacity: 1;
    transform: translateY(0);
  }
  100% {
    opacity: 0;
    transform: translateY(90px);
  }
}

.suggestions {
  margin-top: 18px;
}

.suggestion-header {
  font-weight: bold;
  margin-bottom: 4px;
}

.suggestion-body {
  color: #777;
}

/* Increase line height at higher resolutions. */
@media (min-width: 641px) and (min-height: 641px) {
  #help-box-inner {
    line-height: 18px;
  }
}

/* Decrease padding at low sizes. */
@media (max-width: 640px), (max-height: 640px) {
  h1 {
    margin: 0 0 15px;
  }
  #content-top {
    margin: 15px;
  }
  #help-box-inner {
    padding: 20px;
  }
  .suggestions {
    margin-top: 10px;
  }
  .suggestion-header {
    margin-bottom: 0;
  }
}

#download-link, #download-link-clicked {
  margin-bottom: 30px;
  margin-top: 30px;
}

#download-link-clicked {
  color: #BBB;
}

  #download-link:before, #download-link-clicked:before {
    content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxLjJlbSIgaGVpZ2h0PSIxLjJlbSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNSAyMGgxNHYtMkg1bTE0LTloLTRWM0g5djZINWw3IDcgNy03eiIgZmlsbD0iIzQyODVGNCIvPjwvc3ZnPg==);
    display: inline-block;
    margin-inline-end: 4px;
    vertical-align: -webkit-baseline-middle;
  }

#download-link-clicked:before {
  width: 0px;
  opacity: 0;
}

#offline-content-list-visibility-card {
  border: 1px solid white;
  border-radius: 8px;
  display: flex;
  font-size: .8em;
  justify-content: space-between;
  line-height: 1;
}

#offline-content-list.list-hidden #offline-content-list-visibility-card {
  border-color: rgb(218, 220, 224);
}

#offline-content-list-visibility-card > div {
  padding: 1em;
}

#offline-content-list-title {
  color: var(--google-gray-700);
}

#offline-content-list-show-text, #offline-content-list-hide-text {
  color: rgb(66, 133, 244);
}

/* Hides the "hide" text div when the offline content list is collapsed/hidden
 * and, alternatively, hides the "show" text div when the offline content list
 * is expanded/shown.
 */
#offline-content-list.list-hidden #offline-content-list-hide-text,
#offline-content-list:not(.list-hidden) #offline-content-list-show-text {
  display: none;
}

/* Controls the animation of the offline content list when it is expanded/shown.
 */
#offline-content-suggestions {
  /* Max-height has to be set for the height animation to work. The chosen value
   * is a little greater than the maximum height the list will have, when all
   * suggestions have images, so that it is never clamped. This makes so that
   * when the actual height is smaller then the animation is not as smooth.
   */
  max-height: 27em;
  transition: max-height 0.2s ease-in, visibility 0s 0.2s,
              opacity 0.2s 0.2s linear;
}

/* Controls the animation of the offline content list when it is
 * collapsed/hidden.
 */
#offline-content-list.list-hidden #offline-content-suggestions {
  max-height: 0;
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s linear, visibility 0s 0.2s,
              max-height 0.2s 0.2s ease-out;
}

#offline-content-list {
  margin-inline-start: -5%;
  width: 110%;
}

/* The selectors below adjust the "overflow" of the suggestion cards contents
 * based on the same screen size based strategy used for the main frame, which
 * is applied by the `interstitial-wrapper` class. */
@media (max-width: 420px)  {
  #offline-content-list {
    margin-inline-start: -2.5%;
    width: 105%;
  }
}
@media (max-width: 420px) and (orientation: portrait),
       (max-height: 560px) {
  #offline-content-list {
    margin-inline-start: -12px;
    width: calc(100% + 24px);
  }
}

.suggestion-with-image .offline-content-suggestion-thumbnail {
  flex-basis: 8.2em;
  flex-shrink: 0;
}

.suggestion-with-image .offline-content-suggestion-thumbnail > img {
  height: 100%;
  width: 100%;
}

.suggestion-with-image #offline-content-list:not(.is-rtl)
.offline-content-suggestion-thumbnail > img {
  border-bottom-right-radius: 7px;
  border-top-right-radius: 7px;
}

.suggestion-with-image #offline-content-list.is-rtl
.offline-content-suggestion-thumbnail > img {
  border-bottom-left-radius: 7px;
  border-top-left-radius: 7px;
}

.suggestion-with-icon .offline-content-suggestion-thumbnail {
  align-items: center;
  display: flex;
  justify-content: center;
  min-height: 4.2em;
  min-width: 4.2em;
}

.suggestion-with-icon .offline-content-suggestion-thumbnail > div {
  align-items: center;
  background-color: rgb(241, 243, 244);
  border-radius: 50%;
  display: flex;
  height: 2.3em;
  justify-content: center;
  width: 2.3em;
}

.suggestion-with-icon .offline-content-suggestion-thumbnail > div > img {
  height: 1.45em;
  width: 1.45em;
}

.offline-content-suggestion-favicon {
  height: 1em;
  margin-inline-end: 0.4em;
  width: 1.4em;
}

.offline-content-suggestion-favicon > img {
  height: 1.4em;
  width: 1.4em;
}

.no-favicon .offline-content-suggestion-favicon {
  display: none;
}

.image-video {
  content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTcgMTAuNVY3YTEgMSAwIDAgMC0xLTFINGExIDEgMCAwIDAtMSAxdjEwYTEgMSAwIDAgMCAxIDFoMTJhMSAxIDAgMCAwIDEtMXYtMy41bDQgNHYtMTFsLTQgNHoiIGZpbGw9IiMzQzQwNDMiLz48L3N2Zz4=);
}

.image-music-note {
  content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgM3Y5LjI2Yy0uNS0uMTctMS0uMjYtMS41LS4yNkM4IDEyIDYgMTQgNiAxNi41UzggMjEgMTAuNSAyMXM0LjUtMiA0LjUtNC41VjZoNFYzaC03eiIgZmlsbD0iIzNDNDA0MyIvPjwvc3ZnPg==);
}

.image-earth {
  content: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTIgMmM1LjUyIDAgMTAgNC40OCAxMCAxMHMtNC40OCAxMC0xMCAxMFMyIDE3LjUyIDIgMTIgNi40OCAyIDEyIDJ6TTQgMTJoNC40YzMuNDA3LjAyMiA0LjkyMiAxLjczIDQuNTQzIDUuMTI3SDkuNDg4djIuNDdhOC4wMDQgOC4wMDQgMCAwIDAgMTAuNDk4LTguMDgzQzE5LjMyNyAxMi41MDQgMTguMzMyIDEzIDE3IDEzYy0yLjEzNyAwLTMuMjA2LS45MTYtMy4yMDYtMi43NWgtMy43NDhjLS4yNzQtMi43MjguNjgzLTQuMDkyIDIuODctNC4wOTIgMC0uOTc1LjMyNy0xLjU5Ny44MTEtMS45N0E4LjAwNCA4LjAwNCAwIDAgMCA0IDEyeiIgZmlsbD0iIzNDNDA0MyIvPjwvc3ZnPg==);
}

.image-file {
  content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTMgOVYzLjVMMTguNSA5TTYgMmMtMS4xMSAwLTIgLjg5LTIgMnYxNmEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJWOGwtNi02SDZ6IiBmaWxsPSIjM0M0MDQzIi8+PC9zdmc+);
}

.offline-content-suggestion-texts {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  line-height: 1.3;
  padding: .9em;
  width: 100%;
}

.offline-content-suggestion-title {
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  color: rgb(32, 33, 36);
  display: -webkit-box;
  font-size: 1.1em;
  overflow: hidden;
  text-overflow: ellipsis;
}

div.offline-content-suggestion {
  align-items: stretch;
  border: 1px solid rgb(218, 220, 224);
  border-radius: 8px;
  display: flex;
  justify-content: space-between;
  margin-bottom: .8em;
}

.suggestion-with-image {
  flex-direction: row;
  height: 8.2em;
  max-height: 8.2em;
}

.suggestion-with-icon {
  flex-direction: row-reverse;
  height: 4.2em;
  max-height: 4.2em;
}

.suggestion-with-icon .offline-content-suggestion-title {
  -webkit-line-clamp: 1;
  word-break: break-all;
}

.suggestion-with-icon .offline-content-suggestion-texts {
  padding-inline-start: 0px;
}

.offline-content-suggestion-attribution-freshness {
  color: rgb(95, 99, 104);
  display: flex;
  font-size: .8em;
  line-height: 1.7em;
}

.offline-content-suggestion-attribution {
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 1;
  display: -webkit-box;
  flex-shrink: 1;
  margin-inline-end: 0.3em;
  overflow-wrap: break-word;
  overflow: hidden;
  text-overflow: ellipsis;
  word-break: break-all;
}

.no-attribution .offline-content-suggestion-attribution {
  display: none;
}

.offline-content-suggestion-freshness:before {
  content: '-';
  display: inline-block;
  flex-shrink: 0;
  margin-inline-end: .1em;
  margin-inline-start: .1em;
}

.no-attribution .offline-content-suggestion-freshness:before {
  display: none;
}

.offline-content-suggestion-freshness {
  flex-shrink: 0;
}

.suggestion-with-image .offline-content-suggestion-pin-spacer {
  flex-shrink: 1;
  flex-grow: 100;
}

.suggestion-with-image .offline-content-suggestion-pin {
  content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIDBoMjR2MjRIMFYweiIvPjwvZGVmcz48Y2xpcFBhdGggaWQ9ImIiPjx1c2UgeGxpbms6aHJlZj0iI2EiIG92ZXJmbG93PSJ2aXNpYmxlIi8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjYikiIGQ9Ik0xMiAyQzYuNSAyIDIgNi41IDIgMTJzNC41IDEwIDEwIDEwIDEwLTQuNSAxMC0xMFMxNy41IDIgMTIgMnptNSAxNkg3di0yaDEwdjJ6bS02LjctNEw3IDEwLjdsMS40LTEuNCAxLjkgMS45IDUuMy01LjNMMTcgNy4zIDEwLjMgMTR6IiBmaWxsPSIjOUFBMEE2Ii8+PC9zdmc+);
  flex-shrink: 0;
  height: 1.4em;
  margin-inline-start: .4em;
  width: 1.4em;
}

/* Controls the animation (and a bit more) of the launch-downloads-home action
 * button when the offline content list is expanded/shown.
 */
#offline-content-list-action {
  text-align: center;
  transition: visibility 0s 0.2s, opacity 0.2s 0.2s linear;
}

/* Controls the animation of the launch-downloads-home action button when the
 * offline content list is collapsed/hidden.
 */
#offline-content-list.list-hidden #offline-content-list-action {
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s linear, visibility 0s 0.2s;
}

#cancel-save-page-button {
  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48Y2xpcFBhdGggaWQ9Im1hc2siPjxwYXRoIGQ9Ik0xMiAyQzYuNSAyIDIgNi41IDIgMTJzNC41IDEwIDEwIDEwIDEwLTQuNSAxMC0xMFMxNy41IDIgMTIgMnptNSAxNkg3di0yaDEwdjJ6bS02LjctNEw3IDEwLjdsMS40LTEuNCAxLjkgMS45IDUuMy01LjNMMTcgNy4zIDEwLjMgMTR6IiBmaWxsPSIjOUFBMEE2Ii8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiM5QUEwQTYiIGQ9Ik0wIDBoMjR2MjRIMHoiLz48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiMxQTczRTgiIHN0eWxlPSJhbmltYXRpb246b2ZmbGluZUFuaW1hdGlvbiA0cyBpbmZpbml0ZSIgZD0iTTAgMGgyNHYyNEgweiIvPjxzdHlsZT5Aa2V5ZnJhbWVzIG9mZmxpbmVBbmltYXRpb257MCUsMzUle2hlaWdodDowfTYwJXtoZWlnaHQ6MTAwJX05MCV7ZmlsbC1vcGFjaXR5OjF9dG97ZmlsbC1vcGFjaXR5OjB9fTwvc3R5bGU+PC9zdmc+);
  background-position: right 27px center;
  background-repeat: no-repeat;
  border: 1px solid var(--google-gray-300);
  border-radius: 5px;
  color: var(--google-gray-700);
  margin-bottom: 26px;
  padding-bottom: 16px;
  padding-inline-end: 88px;
  padding-inline-start: 16px;
  padding-top: 16px;
  text-align: start;
}

html[dir="rtl"] #cancel-save-page-button {
  background-position: left 27px center;
}

#save-page-for-later-button {
  display: flex;
  justify-content: start;
}

#save-page-for-later-button a:before {
  content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxLjJlbSIgaGVpZ2h0PSIxLjJlbSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNSAyMGgxNHYtMkg1bTE0LTloLTRWM0g5djZINWw3IDcgNy03eiIgZmlsbD0iIzQyODVGNCIvPjwvc3ZnPg==);
  display: inline-block;
  margin-inline-end: 4px;
  vertical-align: -webkit-baseline-middle;
}

.hidden#save-page-for-later-button {
  display: none;
}

/* Don't allow overflow when in a subframe. */
html[subframe] body {
  overflow: hidden;
}

#sub-frame-error {
  -webkit-align-items: center;
  background-color: #DDD;
  display: -webkit-flex;
  -webkit-flex-flow: column;
  height: 100%;
  -webkit-justify-content: center;
  left: 0;
  position: absolute;
  text-align: center;
  top: 0;
  transition: background-color .2s ease-in-out;
  width: 100%;
}

#sub-frame-error:hover {
  background-color: #EEE;
}

#sub-frame-error .icon-generic {
  margin: 0 0 16px;
}

#sub-frame-error-details {
  margin: 0 10px;
  text-align: center;
  visibility: hidden;
}

/* Show details only when hovering. */
#sub-frame-error:hover #sub-frame-error-details {
  visibility: visible;
}

/* If the iframe is too small, always hide the error code. */
/* TODO(mmenke): See if overflow: no-display works better, once supported. */
@media (max-width: 200px), (max-height: 95px) {
  #sub-frame-error-details {
    display: none;
  }
}

/* Adjust icon for small embedded frames in apps. */
@media (max-height: 100px) {
  #sub-frame-error .icon-generic {
    height: auto;
    margin: 0;
    padding-top: 0;
    width: 25px;
  }
}

/* details-button is special; it's a <button> element that looks like a link. */
#details-button {
  box-shadow: none;
  min-width: 0;
}

/* Styles for platform dependent separation of controls and details button. */
.suggested-left > #control-buttons,
.suggested-right > #details-button {
  float: left;
}

.suggested-right > #control-buttons,
.suggested-left > #details-button {
  float: right;
}

.suggested-left .secondary-button {
  margin-inline-end: 0px;
  margin-inline-start: 16px;
}

#details-button.singular {
  float: none;
}

/* download-button shows both icon and text. */
#download-button {
  padding-bottom: 4px;
  padding-top: 4px;
  position: relative;
}

#download-button:before {
  background: -webkit-image-set(
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAO0lEQVQ4y2NgGArgPxIY1YChsOE/LtBAmpYG0mxpIOSDBpKUo2lpIDZxNJCkHKqlYZAla3RAHQ1DFgAARRroHyLNTwwAAAAASUVORK5CYII=) 1x,
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAQAAAD9CzEMAAAAZElEQVRYw+3Ruw3AMAwDUY3OzZUmRRD4E9iim9wNwAdbEURHyk4AAAAATiCVK8lLyPsKeT9K3lsownnunfkPxO78hKiYHxBV8x2icr5BVM+/CMf8g3DN34Rzns6ViwHUAUQ/6wIAd5Km7l6c8AAAAABJRU5ErkJggg==) 2x)
    no-repeat;
  content: '';
  display: inline-block;
  width: 24px;
  height: 24px;
  margin-inline-end: 4px;
  margin-inline-start: -4px;
  vertical-align: middle;
}

#download-button:disabled {
  background: rgb(180, 206, 249);
  color: rgb(255, 255, 255);
}

/*
TODO(https://crbug.com/852872): UI for offline suggested content is incomplete.
*/
.suggested-thumbnail {
  width: 25vw;
  height: 25vw;
}

/* Alternate dino page button styles */
#control-buttons .reload-button-alternate:disabled {
  background: #ccc;
  color: #fff;
  font-size: 14px;
  height: 48px;
}

#buttons::after {
  clear: both;
  content: '';
  display: block;
  width: 100%;
}

/* Offline page */
.offline {
  transition: filter 1.5s cubic-bezier(0.65, 0.05, 0.36, 1),
              background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);

  will-change: filter, background-color;

}

.offline body {
  transition: background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
}

.offline #main-message > p {
  display: none;
}

/* iOS WKWebView inverts the background color set at the HTML level
whereas Blink does not. */
.offline.inverted {
  filter: invert(1);

  background-color: #000;


}

.offline.inverted body {
  background-color: #fff;
}

.offline .interstitial-wrapper {
  color: var(--text-color);
  font-size: 1em;
  line-height: 1.55;
  margin: 0 auto;
  max-width: 600px;
  padding-top: 100px;
  width: 100%;
}

.offline .runner-container {
  direction: ltr;
  height: 150px;
  max-width: 600px;
  overflow: hidden;
  position: absolute;
  top: 35px;
  width: 44px;
}

.offline .runner-canvas {
  height: 150px;
  max-width: 600px;
  opacity: 1;
  overflow: hidden;
  position: absolute;
  top: 0;
  z-index: 10;
}

.offline .controller {
  background: rgba(247,247,247, .1);
  height: 100vh;
  left: 0;
  position: absolute;
  top: 0;
  width: 100vw;
  z-index: 9;
}

#offline-resources {
  display: none;
}

@media (max-width: 420px) {
  #download-button {
    padding-bottom: 12px;
    padding-top: 12px;
  }

  .suggested-left > #control-buttons,
  .suggested-right > #control-buttons {
    float: none;
  }

  .snackbar {
    left: 0;
    bottom: 0;
    width: 100%;
    border-radius: 0;
  }
}

@media (max-height: 350px) {
  h1 {
    margin: 0 0 15px;
  }

  .icon-offline {
    margin: 0 0 10px;
  }

  .interstitial-wrapper {
    margin-top: 5%;
  }

  .nav-wrapper {
    margin-top: 30px;
  }
}

@media (min-width: 420px) and (max-width: 736px) and
       (min-height: 240px) and (max-height: 420px) and
       (orientation:landscape) {
  .interstitial-wrapper {
    margin-bottom: 100px;
  }
}

@media (max-width: 360px) and (max-height: 480px) {
  .offline .interstitial-wrapper {
    padding-top: 60px;
  }

  .offline .runner-container {
    top: 8px;
  }
}

@media (min-height: 240px) and (orientation: landscape) {
  .offline .interstitial-wrapper {
    margin-bottom: 90px;
  }

  .icon-offline {
    margin-bottom: 20px;
  }
}

@media (max-height: 320px) and (orientation: landscape) {
  .icon-offline {
    margin-bottom: 0;
  }

  .offline .runner-container {
    top: 10px;
  }
}

@media (max-width: 240px) {
  button {
    padding-left: 12px;
    padding-right: 12px;
  }

  .interstitial-wrapper {
    overflow: inherit;
    padding: 0 8px;
  }
}

@media (max-width: 120px) {
  button {
    width: auto;
  }
}

.arcade-mode,
.arcade-mode .runner-container,
.arcade-mode .runner-canvas {
  image-rendering: pixelated;
  max-width: 100%;
  overflow: hidden;
}

.arcade-mode #buttons,
.arcade-mode #main-content {
  opacity: 0;
  overflow: hidden;
}

.arcade-mode .interstitial-wrapper {
  height: 100vh;
  max-width: 100%;
  overflow: hidden;
}

.arcade-mode .runner-container {
  left: 0;
  margin: auto;
  right: 0;
  transform-origin: top center;
  transition: transform 250ms cubic-bezier(0.4, 0.0, 1, 1) .4s;
  z-index: 2;
}

@media (prefers-color-scheme: dark) {
  .icon {
    filter: invert(1);
  }

  .offline .runner-canvas {
    filter: invert(1);
  }

  .offline.inverted {
    filter: invert(0);
  
    background-color: var(--background-color);
  
  
  }

  .offline.inverted body {
    background-color: #fff;
  }

  #suggestions-list a {
    color: var(--link-color);
  }

  #error-information-button {
    filter: invert(0.6);
  }
}
</style>
  <script>// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @typedef {{
 *   downloadButtonClick: function(),
 *   reloadButtonClick: function(),
 *   detailsButtonClick: function(),
 *   diagnoseErrorsButtonClick: function(),
 *   trackEasterEgg: function(),
 *   updateEasterEggHighScore: function(number),
 *   resetEasterEggHighScore: function(),
 *   launchOfflineItem: function(string, string),
 *   savePageForLater: function(),
 *   cancelSavePage: function(),
 *   listVisibilityChange: function(boolean),
 * }}
 */
// eslint-disable-next-line no-var
var errorPageController;

const HIDDEN_CLASS = 'hidden';

// Decodes a UTF16 string that is encoded as base64.
function decodeUTF16Base64ToString(encoded_text) {
  const data = atob(encoded_text);
  let result = '';
  for (let i = 0; i < data.length; i += 2) {
    result +=
        String.fromCharCode(data.charCodeAt(i) * 256 + data.charCodeAt(i + 1));
  }
  return result;
}

function toggleHelpBox() {
  const helpBoxOuter = document.getElementById('details');
  helpBoxOuter.classList.toggle(HIDDEN_CLASS);
  const detailsButton = document.getElementById('details-button');
  if (helpBoxOuter.classList.contains(HIDDEN_CLASS)) {
    /** @suppress {missingProperties} */
    detailsButton.innerText = detailsButton.detailsText;
  } else {
    /** @suppress {missingProperties} */
    detailsButton.innerText = detailsButton.hideDetailsText;
  }

  // Details appears over the main content on small screens.
  if (mobileNav) {
    document.getElementById('main-content').classList.toggle(HIDDEN_CLASS);
    const runnerContainer = document.querySelector('.runner-container');
    if (runnerContainer) {
      runnerContainer.classList.toggle(HIDDEN_CLASS);
    }
  }
}

function diagnoseErrors() {
// 
if (window.errorPageController) {
  errorPageController.diagnoseErrorsButtonClick();
}
// 
// 
}

// Subframes use a different layout but the same html file.  This is to make it
// easier to support platforms that load the error page via different
// mechanisms (Currently just iOS). We also use the subframe style for portals
// as they are embedded like subframes and can't be interacted with by the user.
if (window.top.location !== window.location || window.portalHost) {
  document.documentElement.setAttribute('subframe', '');
}

// Re-renders the error page using |strings| as the dictionary of values.
// Used by NetErrorTabHelper to update DNS error pages with probe results.
function updateForDnsProbe(strings) {
  const context = new JsEvalContext(strings);
  jstProcess(context, document.getElementById('t'));
  onDocumentLoadOrUpdate();
}

// Given the classList property of an element, adds an icon class to the list
// and removes the previously-
function updateIconClass(classList, newClass) {
  let oldClass;

  if (classList.hasOwnProperty('last_icon_class')) {
    oldClass = classList['last_icon_class'];
    if (oldClass === newClass) {
      return;
    }
  }

  classList.add(newClass);
  if (oldClass !== undefined) {
    classList.remove(oldClass);
  }

  classList['last_icon_class'] = newClass;

  if (newClass === 'icon-offline') {
    document.firstElementChild.classList.add('offline');
    new Runner('.interstitial-wrapper');
  } else {
    document.body.classList.add('neterror');
  }
}

// Does a search using |baseSearchUrl| and the text in the search box.
function search(baseSearchUrl) {
  const searchTextNode = document.getElementById('search-box');
  document.location = baseSearchUrl + searchTextNode.value;
  return false;
}

// Implements button clicks.  This function is needed during the transition
// between implementing these in trunk chromium and implementing them in
// iOS.
function reloadButtonClick(url) {
  if (window.errorPageController) {
    errorPageController.reloadButtonClick();
  } else {
    window.location = url;
  }
}

function downloadButtonClick() {
  if (window.errorPageController) {
    errorPageController.downloadButtonClick();
    const downloadButton = document.getElementById('download-button');
    downloadButton.disabled = true;
    /** @suppress {missingProperties} */
    downloadButton.textContent = downloadButton.disabledText;

    document.getElementById('download-link-wrapper')
        .classList.add(HIDDEN_CLASS);
    document.getElementById('download-link-clicked-wrapper')
        .classList.remove(HIDDEN_CLASS);
  }
}

function detailsButtonClick() {
  if (window.errorPageController) {
    errorPageController.detailsButtonClick();
  }
}

let primaryControlOnLeft = true;
// 
primaryControlOnLeft = false;
// 

function setAutoFetchState(scheduled, can_schedule) {
  document.getElementById('cancel-save-page-button')
      .classList.toggle(HIDDEN_CLASS, !scheduled);
  document.getElementById('save-page-for-later-button')
      .classList.toggle(HIDDEN_CLASS, scheduled || !can_schedule);
}

function savePageLaterClick() {
  errorPageController.savePageForLater();
  // savePageForLater will eventually trigger a call to setAutoFetchState() when
  // it completes.
}

function cancelSavePageClick() {
  errorPageController.cancelSavePage();
  // setAutoFetchState is not called in response to cancelSavePage(), so do it
  // now.
  setAutoFetchState(false, true);
}

function toggleErrorInformationPopup() {
  document.getElementById('error-information-popup-container')
      .classList.toggle(HIDDEN_CLASS);
}

function launchOfflineItem(itemID, name_space) {
  errorPageController.launchOfflineItem(itemID, name_space);
}

function launchDownloadsPage() {
  errorPageController.launchDownloadsPage();
}

function getIconForSuggestedItem(item) {
  // Note: |item.content_type| contains the enum values from
  // chrome::mojom::AvailableContentType.
  switch (item.content_type) {
    case 1:  // kVideo
      return 'image-video';
    case 2:  // kAudio
      return 'image-music-note';
    case 0:  // kPrefetchedPage
    case 3:  // kOtherPage
      return 'image-earth';
  }
  return 'image-file';
}

function getSuggestedContentDiv(item, index) {
  // Note: See AvailableContentToValue in available_offline_content_helper.cc
  // for the data contained in an |item|.
  // TODO(carlosk): Present |snippet_base64| when that content becomes
  // available.
  let thumbnail = '';
  const extraContainerClasses = [];
  // html_inline.py will try to replace src attributes with data URIs using a
  // simple regex. The following is obfuscated slightly to avoid that.
  const source = 'src';
  if (item.thumbnail_data_uri) {
    extraContainerClasses.push('suggestion-with-image');
    thumbnail = `<img ${source}="${item.thumbnail_data_uri}">`;
  } else {
    extraContainerClasses.push('suggestion-with-icon');
    const iconClass = getIconForSuggestedItem(item);
    thumbnail = `<div><img class="${iconClass}"></div>`;
  }

  let favicon = '';
  if (item.favicon_data_uri) {
    favicon = `<img ${source}="${item.favicon_data_uri}">`;
  } else {
    extraContainerClasses.push('no-favicon');
  }

  if (!item.attribution_base64) {
    extraContainerClasses.push('no-attribution');
  }

  return `
  <div class="offline-content-suggestion ${extraContainerClasses.join(' ')}"
    onclick="launchOfflineItem('${item.ID}', '${item.name_space}')">
      <div class="offline-content-suggestion-texts">
        <div id="offline-content-suggestion-title-${index}"
             class="offline-content-suggestion-title">
        </div>
        <div class="offline-content-suggestion-attribution-freshness">
          <div id="offline-content-suggestion-favicon-${index}"
               class="offline-content-suggestion-favicon">
            ${favicon}
          </div>
          <div id="offline-content-suggestion-attribution-${index}"
               class="offline-content-suggestion-attribution">
          </div>
          <div class="offline-content-suggestion-freshness">
            ${item.date_modified}
          </div>
          <div class="offline-content-suggestion-pin-spacer"></div>
          <div class="offline-content-suggestion-pin"></div>
        </div>
      </div>
      <div class="offline-content-suggestion-thumbnail">
        ${thumbnail}
      </div>
  </div>`;
}

/**
 * @typedef {{
 *   ID: string,
 *   name_space: string,
 *   title_base64: string,
 *   snippet_base64: string,
 *   date_modified: string,
 *   attribution_base64: string,
 *   thumbnail_data_uri: string,
 *   favicon_data_uri: string,
 *   content_type: number,
 * }}
 */
let AvailableOfflineContent;

// Populates a list of suggested offline content.
// Note: For security reasons all content downloaded from the web is considered
// unsafe and must be securely handled to be presented on the dino page. Images
// have already been safely re-encoded but textual content -- like title and
// attribution -- must be properly handled here.
// @param {boolean} isShown
// @param {Array<AvailableOfflineContent>} suggestions
function offlineContentAvailable(isShown, suggestions) {
  if (!suggestions || !loadTimeData.valueExists('offlineContentList')) {
    return;
  }

  const suggestionsHTML = [];
  for (let index = 0; index < suggestions.length; index++) {
    suggestionsHTML.push(getSuggestedContentDiv(suggestions[index], index));
  }

  document.getElementById('offline-content-suggestions').innerHTML =
      suggestionsHTML.join('\n');

  // Sets textual web content using |textContent| to make sure it's handled as
  // plain text.
  for (let index = 0; index < suggestions.length; index++) {
    document.getElementById(`offline-content-suggestion-title-${index}`)
        .textContent =
        decodeUTF16Base64ToString(suggestions[index].title_base64);
    document.getElementById(`offline-content-suggestion-attribution-${index}`)
        .textContent =
        decodeUTF16Base64ToString(suggestions[index].attribution_base64);
  }

  const contentListElement = document.getElementById('offline-content-list');
  if (document.dir === 'rtl') {
    contentListElement.classList.add('is-rtl');
  }
  contentListElement.hidden = false;
  // The list is configured as hidden by default. Show it if needed.
  if (isShown) {
    toggleOfflineContentListVisibility(false);
  }
}

function toggleOfflineContentListVisibility(updatePref) {
  if (!loadTimeData.valueExists('offlineContentList')) {
    return;
  }

  const contentListElement = document.getElementById('offline-content-list');
  const isVisible = !contentListElement.classList.toggle('list-hidden');

  if (updatePref && window.errorPageController) {
    errorPageController.listVisibilityChanged(isVisible);
  }
}

// Called on document load, and from updateForDnsProbe().
function onDocumentLoadOrUpdate() {
  const downloadButtonVisible = loadTimeData.valueExists('downloadButton') &&
      loadTimeData.getValue('downloadButton').msg;
  const detailsButton = document.getElementById('details-button');

  // If offline content suggestions will be visible, the usual buttons will not
  // be presented.
  const offlineContentVisible =
      loadTimeData.valueExists('suggestedOfflineContentPresentation');
  if (offlineContentVisible) {
    document.querySelector('.nav-wrapper').classList.add(HIDDEN_CLASS);
    detailsButton.classList.add(HIDDEN_CLASS);

    document.getElementById('download-link').hidden = !downloadButtonVisible;
    document.getElementById('download-links-wrapper')
        .classList.remove(HIDDEN_CLASS);
    document.getElementById('error-information-popup-container')
        .classList.add('use-popup-container', HIDDEN_CLASS);
    document.getElementById('error-information-button')
        .classList.remove(HIDDEN_CLASS);
  }

  const attemptAutoFetch = loadTimeData.valueExists('attemptAutoFetch') &&
      loadTimeData.getValue('attemptAutoFetch');

  const reloadButtonVisible = loadTimeData.valueExists('reloadButton') &&
      loadTimeData.getValue('reloadButton').msg;

  const reloadButton = document.getElementById('reload-button');
  const downloadButton = document.getElementById('download-button');
  if (reloadButton.style.display === 'none' &&
      downloadButton.style.display === 'none') {
    detailsButton.classList.add('singular');
  }

  // Show or hide control buttons.
  const controlButtonDiv = document.getElementById('control-buttons');
  controlButtonDiv.hidden =
      offlineContentVisible || !(reloadButtonVisible || downloadButtonVisible);
}

function onDocumentLoad() {
  // Sets up the proper button layout for the current platform.
  const buttonsDiv = document.getElementById('buttons');
  if (primaryControlOnLeft) {
    buttonsDiv.classList.add('suggested-left');
  } else {
    buttonsDiv.classList.add('suggested-right');
  }

  onDocumentLoadOrUpdate();
}

document.addEventListener('DOMContentLoaded', onDocumentLoad);
</script>
  <script>// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

let mobileNav = false;

/**
 * For small screen mobile the navigation buttons are moved
 * below the advanced text.
 */
function onResize() {
  const helpOuterBox = document.querySelector('#details');
  const mainContent = document.querySelector('#main-content');
  const mediaQuery = '(min-width: 240px) and (max-width: 420px) and ' +
      '(min-height: 401px), ' +
      '(max-height: 560px) and (min-height: 240px) and ' +
      '(min-width: 421px)';

  const detailsHidden = helpOuterBox.classList.contains(HIDDEN_CLASS);
  const runnerContainer = document.querySelector('.runner-container');

  // Check for change in nav status.
  if (mobileNav !== window.matchMedia(mediaQuery).matches) {
    mobileNav = !mobileNav;

    // Handle showing the top content / details sections according to state.
    if (mobileNav) {
      mainContent.classList.toggle(HIDDEN_CLASS, !detailsHidden);
      helpOuterBox.classList.toggle(HIDDEN_CLASS, detailsHidden);
      if (runnerContainer) {
        runnerContainer.classList.toggle(HIDDEN_CLASS, !detailsHidden);
      }
    } else if (!detailsHidden) {
      // Non mobile nav with visible details.
      mainContent.classList.remove(HIDDEN_CLASS);
      helpOuterBox.classList.remove(HIDDEN_CLASS);
      if (runnerContainer) {
        runnerContainer.classList.remove(HIDDEN_CLASS);
      }
    }
  }
}

function setupMobileNav() {
  window.addEventListener('resize', onResize);
  onResize();
}

document.addEventListener('DOMContentLoaded', setupMobileNav);
</script>
  <script>// Copyright (c) 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * T-Rex runner.
 * @param {string} outerContainerId Outer containing element id.
 * @param {!Object=} opt_config
 * @constructor
 * @implements {EventListener}
 * @export
 */
function Runner(outerContainerId, opt_config) {
  // Singleton
  if (Runner.instance_) {
    return Runner.instance_;
  }
  Runner.instance_ = this;

  this.outerContainerEl = document.querySelector(outerContainerId);
  this.containerEl = null;
  this.snackbarEl = null;
  // A div to intercept touch events. Only set while (playing && useTouch).
  this.touchController = null;

  this.config = opt_config || Runner.config;
  // Logical dimensions of the container.
  this.dimensions = Runner.defaultDimensions;

  this.canvas = null;
  this.canvasCtx = null;

  this.tRex = null;

  this.distanceMeter = null;
  this.distanceRan = 0;

  this.highestScore = 0;
  this.syncHighestScore = false;

  this.time = 0;
  this.runningTime = 0;
  this.msPerFrame = 1000 / FPS;
  this.currentSpeed = this.config.SPEED;

  this.obstacles = [];

  this.activated = false; // Whether the easter egg has been activated.
  this.playing = false; // Whether the game is currently in play state.
  this.crashed = false;
  this.paused = false;
  this.inverted = false;
  this.invertTimer = 0;
  this.resizeTimerId_ = null;

  this.playCount = 0;

  // Sound FX.
  this.audioBuffer = null;
  /** @type {Object} */
  this.soundFx = {};

  // Global web audio context for playing sounds.
  this.audioContext = null;

  // Images.
  this.images = {};
  this.imagesLoaded = 0;

  // Gamepad state.
  this.pollingGamepads = false;
  this.gamepadIndex = undefined;
  this.previousGamepad = null;

  if (this.isDisabled()) {
    this.setupDisabledRunner();
  } else {
    this.loadImages();

    window['initializeEasterEggHighScore'] =
        this.initializeHighScore.bind(this);
  }
}

/**
 * Default game width.
 * @const
 */
const DEFAULT_WIDTH = 600;

/**
 * Frames per second.
 * @const
 */
const FPS = 60;

/** @const */
const IS_HIDPI = window.devicePixelRatio > 1;

/** @const */
const IS_IOS = /CriOS/.test(window.navigator.userAgent);

/** @const */
const IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;

/** @const */
const ARCADE_MODE_URL = 'chrome://dino/';

/**
 * Default game configuration.
 */
Runner.config = {
  ACCELERATION: 0.001,
  BG_CLOUD_SPEED: 0.2,
  BOTTOM_PAD: 10,
  // Scroll Y threshold at which the game can be activated.
  CANVAS_IN_VIEW_OFFSET: -10,
  CLEAR_TIME: 3000,
  CLOUD_FREQUENCY: 0.5,
  GAMEOVER_CLEAR_TIME: 750,
  GAP_COEFFICIENT: 0.6,
  GRAVITY: 0.6,
  INITIAL_JUMP_VELOCITY: 12,
  INVERT_FADE_DURATION: 12000,
  INVERT_DISTANCE: 700,
  MAX_BLINK_COUNT: 3,
  MAX_CLOUDS: 6,
  MAX_OBSTACLE_LENGTH: 3,
  MAX_OBSTACLE_DUPLICATION: 2,
  MAX_SPEED: 13,
  MIN_JUMP_HEIGHT: 35,
  MOBILE_SPEED_COEFFICIENT: 1.2,
  RESOURCE_TEMPLATE_ID: 'audio-resources',
  SPEED: 6,
  SPEED_DROP_COEFFICIENT: 3,
  ARCADE_MODE_INITIAL_TOP_POSITION: 35,
  ARCADE_MODE_TOP_POSITION_PERCENT: 0.1
};


/**
 * Default dimensions.
 */
Runner.defaultDimensions = {
  WIDTH: DEFAULT_WIDTH,
  HEIGHT: 150
};


/**
 * CSS class names.
 * @enum {string}
 */
Runner.classes = {
  ARCADE_MODE: 'arcade-mode',
  CANVAS: 'runner-canvas',
  CONTAINER: 'runner-container',
  CRASHED: 'crashed',
  ICON: 'icon-offline',
  INVERTED: 'inverted',
  SNACKBAR: 'snackbar',
  SNACKBAR_SHOW: 'snackbar-show',
  TOUCH_CONTROLLER: 'controller'
};


/**
 * Sprite definition layout of the spritesheet.
 * @enum {Object}
 */
Runner.spriteDefinition = {
  LDPI: {
    CACTUS_LARGE: {x: 332, y: 2},
    CACTUS_SMALL: {x: 228, y: 2},
    CLOUD: {x: 86, y: 2},
    HORIZON: {x: 2, y: 54},
    MOON: {x: 484, y: 2},
    PTERODACTYL: {x: 134, y: 2},
    RESTART: {x: 2, y: 2},
    TEXT_SPRITE: {x: 655, y: 2},
    TREX: {x: 848, y: 2},
    STAR: {x: 645, y: 2}
  },
  HDPI: {
    CACTUS_LARGE: {x: 652, y: 2},
    CACTUS_SMALL: {x: 446, y: 2},
    CLOUD: {x: 166, y: 2},
    HORIZON: {x: 2, y: 104},
    MOON: {x: 954, y: 2},
    PTERODACTYL: {x: 260, y: 2},
    RESTART: {x: 2, y: 2},
    TEXT_SPRITE: {x: 1294, y: 2},
    TREX: {x: 1678, y: 2},
    STAR: {x: 1276, y: 2}
  }
};


/**
 * Sound FX. Reference to the ID of the audio tag on interstitial page.
 * @enum {string}
 */
Runner.sounds = {
  BUTTON_PRESS: 'offline-sound-press',
  HIT: 'offline-sound-hit',
  SCORE: 'offline-sound-reached'
};


/**
 * Key code mapping.
 * @enum {Object}
 */
Runner.keycodes = {
  JUMP: {'38': 1, '32': 1},  // Up, spacebar
  DUCK: {'40': 1},  // Down
  RESTART: {'13': 1}  // Enter
};


/**
 * Runner event names.
 * @enum {string}
 */
Runner.events = {
  ANIM_END: 'webkitAnimationEnd',
  CLICK: 'click',
  KEYDOWN: 'keydown',
  KEYUP: 'keyup',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  RESIZE: 'resize',
  TOUCHEND: 'touchend',
  TOUCHSTART: 'touchstart',
  VISIBILITY: 'visibilitychange',
  BLUR: 'blur',
  FOCUS: 'focus',
  LOAD: 'load',
  GAMEPADCONNECTED: 'gamepadconnected',
};

Runner.prototype = {
  /**
   * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.
   * @return {boolean}
   */
  isDisabled() {
    return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');
  },

  /**
   * For disabled instances, set up a snackbar with the disabled message.
   */
  setupDisabledRunner() {
    this.containerEl = document.createElement('div');
    this.containerEl.className = Runner.classes.SNACKBAR;
    this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');
    this.outerContainerEl.appendChild(this.containerEl);

    // Show notification when the activation key is pressed.
    document.addEventListener(Runner.events.KEYDOWN, function(e) {
      if (Runner.keycodes.JUMP[e.keyCode]) {
        this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);
        document.querySelector('.icon').classList.add('icon-disabled');
      }
    }.bind(this));
  },

  /**
   * Setting individual settings for debugging.
   * @param {string} setting
   * @param {number|string} value
   */
  updateConfigSetting(setting, value) {
    if (setting in this.config && value !== undefined) {
      this.config[setting] = value;

      switch (setting) {
        case 'GRAVITY':
        case 'MIN_JUMP_HEIGHT':
        case 'SPEED_DROP_COEFFICIENT':
          this.tRex.config[setting] = value;
          break;
        case 'INITIAL_JUMP_VELOCITY':
          this.tRex.setJumpVelocity(value);
          break;
        case 'SPEED':
          this.setSpeed(/** @type {number} */ (value));
          break;
      }
    }
  },

  /**
   * Cache the appropriate image sprite from the page and get the sprite sheet
   * definition.
   */
  loadImages() {
    if (IS_HIDPI) {
      Runner.imageSprite = /** @type {HTMLImageElement} */
          (document.getElementById('offline-resources-2x'));
      this.spriteDef = Runner.spriteDefinition.HDPI;
    } else {
      Runner.imageSprite = /** @type {HTMLImageElement} */
          (document.getElementById('offline-resources-1x'));
      this.spriteDef = Runner.spriteDefinition.LDPI;
    }

    if (Runner.imageSprite.complete) {
      this.init();
    } else {
      // If the images are not yet loaded, add a listener.
      Runner.imageSprite.addEventListener(Runner.events.LOAD,
          this.init.bind(this));
    }
  },

  /**
   * Load and decode base 64 encoded sounds.
   */
  loadSounds() {
    if (!IS_IOS) {
      this.audioContext = new AudioContext();

      const resourceTemplate =
          document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;

      for (const sound in Runner.sounds) {
        let soundSrc =
            resourceTemplate.getElementById(Runner.sounds[sound]).src;
        soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);
        const buffer = decodeBase64ToArrayBuffer(soundSrc);

        // Async, so no guarantee of order in array.
        this.audioContext.decodeAudioData(buffer, function(index, audioData) {
            this.soundFx[index] = audioData;
          }.bind(this, sound));
      }
    }
  },

  /**
   * Sets the game speed. Adjust the speed accordingly if on a smaller screen.
   * @param {number=} opt_speed
   */
  setSpeed(opt_speed) {
    const speed = opt_speed || this.currentSpeed;

    // Reduce the speed on smaller mobile screens.
    if (this.dimensions.WIDTH < DEFAULT_WIDTH) {
      const mobileSpeed = speed * this.dimensions.WIDTH / DEFAULT_WIDTH *
          this.config.MOBILE_SPEED_COEFFICIENT;
      this.currentSpeed = mobileSpeed > speed ? speed : mobileSpeed;
    } else if (opt_speed) {
      this.currentSpeed = opt_speed;
    }
  },

  /**
   * Game initialiser.
   */
  init() {
    // Hide the static icon.
    document.querySelector('.' + Runner.classes.ICON).style.visibility =
        'hidden';

    this.adjustDimensions();
    this.setSpeed();

    this.containerEl = document.createElement('div');
    this.containerEl.className = Runner.classes.CONTAINER;

    // Player canvas container.
    this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,
        this.dimensions.HEIGHT);

    this.canvasCtx =
        /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
    this.canvasCtx.fillStyle = '#f7f7f7';
    this.canvasCtx.fill();
    Runner.updateCanvasScaling(this.canvas);

    // Horizon contains clouds, obstacles and the ground.
    this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,
        this.config.GAP_COEFFICIENT);

    // Distance meter
    this.distanceMeter = new DistanceMeter(this.canvas,
          this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);

    // Draw t-rex
    this.tRex = new Trex(this.canvas, this.spriteDef.TREX);

    this.outerContainerEl.appendChild(this.containerEl);

    this.startListening();
    this.update();

    window.addEventListener(Runner.events.RESIZE,
        this.debounceResize.bind(this));

    // Handle dark mode
    const darkModeMediaQuery =
        window.matchMedia('(prefers-color-scheme: dark)');
    this.isDarkMode = darkModeMediaQuery && darkModeMediaQuery.matches;
    darkModeMediaQuery.addListener((e) => {
      this.isDarkMode = e.matches;
    });
  },

  /**
   * Create the touch controller. A div that covers whole screen.
   */
  createTouchController() {
    this.touchController = document.createElement('div');
    this.touchController.className = Runner.classes.TOUCH_CONTROLLER;
    this.touchController.addEventListener(Runner.events.TOUCHSTART, this);
    this.touchController.addEventListener(Runner.events.TOUCHEND, this);
    this.outerContainerEl.appendChild(this.touchController);
  },

  /**
   * Debounce the resize event.
   */
  debounceResize() {
    if (!this.resizeTimerId_) {
      this.resizeTimerId_ =
          setInterval(this.adjustDimensions.bind(this), 250);
    }
  },

  /**
   * Adjust game space dimensions on resize.
   */
  adjustDimensions() {
    clearInterval(this.resizeTimerId_);
    this.resizeTimerId_ = null;

    const boxStyles = window.getComputedStyle(this.outerContainerEl);
    const padding = Number(boxStyles.paddingLeft.substr(0,
        boxStyles.paddingLeft.length - 2));

    this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;
    if (this.isArcadeMode()) {
      this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);
      if (this.activated) {
        this.setArcadeModeContainerScale();
      }
    }

    // Redraw the elements back onto the canvas.
    if (this.canvas) {
      this.canvas.width = this.dimensions.WIDTH;
      this.canvas.height = this.dimensions.HEIGHT;

      Runner.updateCanvasScaling(this.canvas);

      this.distanceMeter.calcXPos(this.dimensions.WIDTH);
      this.clearCanvas();
      this.horizon.update(0, 0, true);
      this.tRex.update(0);

      // Outer container and distance meter.
      if (this.playing || this.crashed || this.paused) {
        this.containerEl.style.width = this.dimensions.WIDTH + 'px';
        this.containerEl.style.height = this.dimensions.HEIGHT + 'px';
        this.distanceMeter.update(0, Math.ceil(this.distanceRan));
        this.stop();
      } else {
        this.tRex.draw(0, 0);
      }

      // Game over panel.
      if (this.crashed && this.gameOverPanel) {
        this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);
        this.gameOverPanel.draw();
      }
    }
  },

  /**
   * Play the game intro.
   * Canvas container width expands out to the full width.
   */
  playIntro() {
    if (!this.activated && !this.crashed) {
      this.playingIntro = true;
      this.tRex.playingIntro = true;

      // CSS animation definition.
      const keyframes = '@-webkit-keyframes intro { ' +
            'from { width:' + Trex.config.WIDTH + 'px }' +
            'to { width: ' + this.dimensions.WIDTH + 'px }' +
          '}';
      document.styleSheets[0].insertRule(keyframes, 0);

      this.containerEl.addEventListener(Runner.events.ANIM_END,
          this.startGame.bind(this));

      this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';
      this.containerEl.style.width = this.dimensions.WIDTH + 'px';

      this.setPlayStatus(true);
      this.activated = true;
    } else if (this.crashed) {
      this.restart();
    }
  },


  /**
   * Update the game status to started.
   */
  startGame() {
    if (this.isArcadeMode()) {
      this.setArcadeMode();
    }
    this.runningTime = 0;
    this.playingIntro = false;
    this.tRex.playingIntro = false;
    this.containerEl.style.webkitAnimation = '';
    this.playCount++;

    // Handle tabbing off the page. Pause the current game.
    document.addEventListener(Runner.events.VISIBILITY,
          this.onVisibilityChange.bind(this));

    window.addEventListener(Runner.events.BLUR,
          this.onVisibilityChange.bind(this));

    window.addEventListener(Runner.events.FOCUS,
          this.onVisibilityChange.bind(this));
  },

  clearCanvas() {
    this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,
        this.dimensions.HEIGHT);
  },

  /**
   * Checks whether the canvas area is in the viewport of the browser
   * through the current scroll position.
   * @return boolean.
   */
  isCanvasInView() {
    return this.containerEl.getBoundingClientRect().top >
        Runner.config.CANVAS_IN_VIEW_OFFSET;
  },

  /**
   * Update the game frame and schedules the next one.
   */
  update() {
    this.updatePending = false;

    const now = getTimeStamp();
    let deltaTime = now - (this.time || now);

    this.time = now;

    if (this.playing) {
      this.clearCanvas();

      if (this.tRex.jumping) {
        this.tRex.updateJump(deltaTime);
      }

      this.runningTime += deltaTime;
      const hasObstacles = this.runningTime > this.config.CLEAR_TIME;

      // First jump triggers the intro.
      if (this.tRex.jumpCount === 1 && !this.playingIntro) {
        this.playIntro();
      }

      // The horizon doesn't move until the intro is over.
      if (this.playingIntro) {
        this.horizon.update(0, this.currentSpeed, hasObstacles);
      } else {
        const showNightMode = this.isDarkMode ^ this.inverted;
        deltaTime = !this.activated ? 0 : deltaTime;
        this.horizon.update(
            deltaTime, this.currentSpeed, hasObstacles, showNightMode);
      }

      // Check for collisions.
      const collision = hasObstacles &&
          checkForCollision(this.horizon.obstacles[0], this.tRex);

      if (!collision) {
        this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;

        if (this.currentSpeed < this.config.MAX_SPEED) {
          this.currentSpeed += this.config.ACCELERATION;
        }
      } else {
        this.gameOver();
      }

      const playAchievementSound = this.distanceMeter.update(deltaTime,
          Math.ceil(this.distanceRan));

      if (playAchievementSound) {
        this.playSound(this.soundFx.SCORE);
      }

      // Night mode.
      if (this.invertTimer > this.config.INVERT_FADE_DURATION) {
        this.invertTimer = 0;
        this.invertTrigger = false;
        this.invert(false);
      } else if (this.invertTimer) {
        this.invertTimer += deltaTime;
      } else {
        const actualDistance =
            this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));

        if (actualDistance > 0) {
          this.invertTrigger = !(actualDistance %
              this.config.INVERT_DISTANCE);

          if (this.invertTrigger && this.invertTimer === 0) {
            this.invertTimer += deltaTime;
            this.invert(false);
          }
        }
      }
    }

    if (this.playing || (!this.activated &&
        this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {
      this.tRex.update(deltaTime);
      this.scheduleNextUpdate();
    }
  },

  /**
   * Event handler.
   * @param {Event} e
   */
  handleEvent(e) {
    return (function(evtType, events) {
      switch (evtType) {
        case events.KEYDOWN:
        case events.TOUCHSTART:
        case events.POINTERDOWN:
          this.onKeyDown(e);
          break;
        case events.KEYUP:
        case events.TOUCHEND:
        case events.POINTERUP:
          this.onKeyUp(e);
          break;
        case events.GAMEPADCONNECTED:
          this.onGamepadConnected(e);
          break;
      }
    }.bind(this))(e.type, Runner.events);
  },

  /**
   * Bind relevant key / mouse / touch listeners.
   */
  startListening() {
    // Keys.
    document.addEventListener(Runner.events.KEYDOWN, this);
    document.addEventListener(Runner.events.KEYUP, this);

    // Touch / pointer.
    this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);
    document.addEventListener(Runner.events.POINTERDOWN, this);
    document.addEventListener(Runner.events.POINTERUP, this);

    if (this.isArcadeMode()) {
      // Gamepad
      window.addEventListener(Runner.events.GAMEPADCONNECTED, this);
    }
  },

  /**
   * Remove all listeners.
   */
  stopListening() {
    document.removeEventListener(Runner.events.KEYDOWN, this);
    document.removeEventListener(Runner.events.KEYUP, this);

    if (this.touchController) {
      this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);
      this.touchController.removeEventListener(Runner.events.TOUCHEND, this);
    }

    this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);
    document.removeEventListener(Runner.events.POINTERDOWN, this);
    document.removeEventListener(Runner.events.POINTERUP, this);

    if (this.isArcadeMode()) {
      window.removeEventListener(Runner.events.GAMEPADCONNECTED, this);
    }
  },

  /**
   * Process keydown.
   * @param {Event} e
   */
  onKeyDown(e) {
    // Prevent native page scrolling whilst tapping on mobile.
    if (IS_MOBILE && this.playing) {
      e.preventDefault();
    }

    if (this.isCanvasInView()) {
      if (!this.crashed && !this.paused) {
        if (Runner.keycodes.JUMP[e.keyCode] ||
            e.type === Runner.events.TOUCHSTART) {
          e.preventDefault();
          // Starting the game for the first time.
          if (!this.playing) {
            // Started by touch so create a touch controller.
            if (!this.touchController && e.type === Runner.events.TOUCHSTART) {
              this.createTouchController();
            }
            this.loadSounds();
            this.setPlayStatus(true);
            this.update();
            if (window.errorPageController) {
              errorPageController.trackEasterEgg();
            }
          }
          // Start jump.
          if (!this.tRex.jumping && !this.tRex.ducking) {
            this.playSound(this.soundFx.BUTTON_PRESS);
            this.tRex.startJump(this.currentSpeed);
          }
        } else if (this.playing && Runner.keycodes.DUCK[e.keyCode]) {
          e.preventDefault();
          if (this.tRex.jumping) {
            // Speed drop, activated only when jump key is not pressed.
            this.tRex.setSpeedDrop();
          } else if (!this.tRex.jumping && !this.tRex.ducking) {
            // Duck.
            this.tRex.setDuck(true);
          }
        }
        // iOS only triggers touchstart and no pointer events.
      } else if (
          IS_IOS && this.crashed && e.type === Runner.events.TOUCHSTART &&
          e.currentTarget === this.containerEl) {
        this.handleGameOverClicks(e);
      }
    }
  },

  /**
   * Process key up.
   * @param {Event} e
   */
  onKeyUp(e) {
    const keyCode = String(e.keyCode);
    const isjumpKey = Runner.keycodes.JUMP[keyCode] ||
        e.type === Runner.events.TOUCHEND || e.type === Runner.events.POINTERUP;

    if (this.isRunning() && isjumpKey) {
      this.tRex.endJump();
    } else if (Runner.keycodes.DUCK[keyCode]) {
      this.tRex.speedDrop = false;
      this.tRex.setDuck(false);
    } else if (this.crashed) {
      // Check that enough time has elapsed before allowing jump key to restart.
      const deltaTime = getTimeStamp() - this.time;

      if (this.isCanvasInView() &&
          (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||
          (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&
          Runner.keycodes.JUMP[keyCode]))) {
        this.handleGameOverClicks(e);
      }
    } else if (this.paused && isjumpKey) {
      // Reset the jump state
      this.tRex.reset();
      this.play();
    }
  },

  /**
   * Process gamepad connected event.
   * @param {Event} e
   */
  onGamepadConnected(e) {
    if (!this.pollingGamepads) {
      this.pollGamepadState();
    }
  },

  /**
   * rAF loop for gamepad polling.
   */
  pollGamepadState() {
    const gamepads = navigator.getGamepads();
    this.pollActiveGamepad(gamepads);

    this.pollingGamepads = true;
    requestAnimationFrame(this.pollGamepadState.bind(this));
  },

  /**
   * Polls for a gamepad with the jump button pressed. If one is found this
   * becomes the "active" gamepad and all others are ignored.
   * @param {!Array<Gamepad>} gamepads
   */
  pollForActiveGamepad(gamepads) {
    for (let i = 0; i < gamepads.length; ++i) {
      if (gamepads[i] && gamepads[i].buttons.length > 0 &&
          gamepads[i].buttons[0].pressed) {
        this.gamepadIndex = i;
        this.pollActiveGamepad(gamepads);
        return;
      }
    }
  },

  /**
   * Polls the chosen gamepad for button presses and generates KeyboardEvents
   * to integrate with the rest of the game logic.
   * @param {!Array<Gamepad>} gamepads
   */
  pollActiveGamepad(gamepads) {
    if (this.gamepadIndex === undefined) {
      this.pollForActiveGamepad(gamepads);
      return;
    }

    const gamepad = gamepads[this.gamepadIndex];
    if (!gamepad) {
      this.gamepadIndex = undefined;
      this.pollForActiveGamepad(gamepads);
      return;
    }

    // The gamepad specification defines the typical mapping of physical buttons
    // to button indicies: https://w3c.github.io/gamepad/#remapping
    this.pollGamepadButton(gamepad, 0, 38);  // Jump
    if (gamepad.buttons.length >= 2) {
      this.pollGamepadButton(gamepad, 1, 40);  // Duck
    }
    if (gamepad.buttons.length >= 10) {
      this.pollGamepadButton(gamepad, 9, 13);  // Restart
    }

    this.previousGamepad = gamepad;
  },

  /**
   * Generates a key event based on a gamepad button.
   * @param {!Gamepad} gamepad
   * @param {number} buttonIndex
   * @param {number} keyCode
   */
  pollGamepadButton(gamepad, buttonIndex, keyCode) {
    const state = gamepad.buttons[buttonIndex].pressed;
    let previousState = false;
    if (this.previousGamepad) {
      previousState = this.previousGamepad.buttons[buttonIndex].pressed;
    }
    // Generate key events on the rising and falling edge of a button press.
    if (state !== previousState) {
      const e = new KeyboardEvent(state ? Runner.events.KEYDOWN
                                      : Runner.events.KEYUP,
                                { keyCode: keyCode });
      document.dispatchEvent(e);
    }
  },

  /**
   * Handle interactions on the game over screen state.
   * A user is able to tap the high score twice to reset it.
   * @param {Event} e
   */
  handleGameOverClicks(e) {
    e.preventDefault();
    if (this.distanceMeter.hasClickedOnHighScore(e) && this.highestScore) {
      if (this.distanceMeter.isHighScoreFlashing()) {
        // Subsequent click, reset the high score.
        this.saveHighScore(0, true);
        this.distanceMeter.resetHighScore();
      } else {
        // First click, flash the high score.
        this.distanceMeter.startHighScoreFlashing();
      }
    } else {
      this.distanceMeter.cancelHighScoreFlashing();
      this.restart();
    }
  },

  /**
   * Returns whether the event was a left click on canvas.
   * On Windows right click is registered as a click.
   * @param {Event} e
   * @return {boolean}
   */
  isLeftClickOnCanvas(e) {
    return e.button != null && e.button < 2 &&
        e.type === Runner.events.POINTERUP && e.target === this.canvas;
  },

  /**
   * RequestAnimationFrame wrapper.
   */
  scheduleNextUpdate() {
    if (!this.updatePending) {
      this.updatePending = true;
      this.raqId = requestAnimationFrame(this.update.bind(this));
    }
  },

  /**
   * Whether the game is running.
   * @return {boolean}
   */
  isRunning() {
    return !!this.raqId;
  },

  /**
   * Set the initial high score as stored in the user's profile.
   * @param {number} highScore
   */
  initializeHighScore(highScore) {
    this.syncHighestScore = true;
    highScore = Math.ceil(highScore);
    if (highScore < this.highestScore) {
      if (window.errorPageController) {
        errorPageController.updateEasterEggHighScore(this.highestScore);
      }
      return;
    }
    this.highestScore = highScore;
    this.distanceMeter.setHighScore(this.highestScore);
  },

  /**
   * Sets the current high score and saves to the profile if available.
   * @param {number} distanceRan Total distance ran.
   * @param {boolean=} opt_resetScore Whether to reset the score.
   */
  saveHighScore(distanceRan, opt_resetScore) {
    this.highestScore = Math.ceil(distanceRan);
    this.distanceMeter.setHighScore(this.highestScore);

    // Store the new high score in the profile.
    if (this.syncHighestScore && window.errorPageController) {
      if (opt_resetScore) {
        errorPageController.resetEasterEggHighScore();
      } else {
        errorPageController.updateEasterEggHighScore(this.highestScore);
      }
    }
  },

  /**
   * Game over state.
   */
  gameOver() {
    this.playSound(this.soundFx.HIT);
    vibrate(200);

    this.stop();
    this.crashed = true;
    this.distanceMeter.achievement = false;

    this.tRex.update(100, Trex.status.CRASHED);

    // Game over panel.
    if (!this.gameOverPanel) {
      if (this.canvas) {
        this.gameOverPanel = new GameOverPanel(this.canvas,
            this.spriteDef.TEXT_SPRITE, this.spriteDef.RESTART,
            this.dimensions);
      }
    } else {
      this.gameOverPanel.draw();
    }

    // Update the high score.
    if (this.distanceRan > this.highestScore) {
      this.saveHighScore(this.distanceRan);
    }

    // Reset the time clock.
    this.time = getTimeStamp();
  },

  stop() {
    this.setPlayStatus(false);
    this.paused = true;
    cancelAnimationFrame(this.raqId);
    this.raqId = 0;
  },

  play() {
    if (!this.crashed) {
      this.setPlayStatus(true);
      this.paused = false;
      this.tRex.update(0, Trex.status.RUNNING);
      this.time = getTimeStamp();
      this.update();
    }
  },

  restart() {
    if (!this.raqId) {
      this.playCount++;
      this.runningTime = 0;
      this.setPlayStatus(true);
      this.paused = false;
      this.crashed = false;
      this.distanceRan = 0;
      this.setSpeed(this.config.SPEED);
      this.time = getTimeStamp();
      this.containerEl.classList.remove(Runner.classes.CRASHED);
      this.clearCanvas();
      this.distanceMeter.reset();
      this.horizon.reset();
      this.tRex.reset();
      this.playSound(this.soundFx.BUTTON_PRESS);
      this.invert(true);
      this.bdayFlashTimer = null;
      this.update();
    }
  },

  setPlayStatus(isPlaying) {
    if (this.touchController) {
      this.touchController.classList.toggle(HIDDEN_CLASS, !isPlaying);
    }
    this.playing = isPlaying;
  },

  /**
   * Whether the game should go into arcade mode.
   * @return {boolean}
   */
  isArcadeMode() {
    return document.title === ARCADE_MODE_URL;
  },

  /**
   * Hides offline messaging for a fullscreen game only experience.
   */
  setArcadeMode() {
    document.body.classList.add(Runner.classes.ARCADE_MODE);
    this.setArcadeModeContainerScale();
  },

  /**
   * Sets the scaling for arcade mode.
   */
  setArcadeModeContainerScale() {
    const windowHeight = window.innerHeight;
    const scaleHeight = windowHeight / this.dimensions.HEIGHT;
    const scaleWidth = window.innerWidth / this.dimensions.WIDTH;
    const scale = Math.max(1, Math.min(scaleHeight, scaleWidth));
    const scaledCanvasHeight = this.dimensions.HEIGHT * scale;
    // Positions the game container at 10% of the available vertical window
    // height minus the game container height.
    const translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -
        Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *
        Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *
        window.devicePixelRatio;
    this.containerEl.style.transform = 'scale(' + scale + ') translateY(' +
        translateY + 'px)';
  },

  /**
   * Pause the game if the tab is not in focus.
   */
  onVisibilityChange(e) {
    if (document.hidden || document.webkitHidden || e.type === 'blur' ||
        document.visibilityState !== 'visible') {
      this.stop();
    } else if (!this.crashed) {
      this.tRex.reset();
      this.play();
    }
  },

  /**
   * Play a sound.
   * @param {AudioBuffer} soundBuffer
   */
  playSound(soundBuffer) {
    if (soundBuffer) {
      const sourceNode = this.audioContext.createBufferSource();
      sourceNode.buffer = soundBuffer;
      sourceNode.connect(this.audioContext.destination);
      sourceNode.start(0);
    }
  },

  /**
   * Inverts the current page / canvas colors.
   * @param {boolean} reset Whether to reset colors.
   */
  invert(reset) {
    const htmlEl = document.firstElementChild;

    if (reset) {
      htmlEl.classList.toggle(Runner.classes.INVERTED,
          false);
      this.invertTimer = 0;
      this.inverted = false;
    } else {
      this.inverted = htmlEl.classList.toggle(
          Runner.classes.INVERTED, this.invertTrigger);
    }
  }
};


/**
 * Updates the canvas size taking into
 * account the backing store pixel ratio and
 * the device pixel ratio.
 *
 * See article by Paul Lewis:
 * http://www.html5rocks.com/en/tutorials/canvas/hidpi/
 *
 * @param {HTMLCanvasElement} canvas
 * @param {number=} opt_width
 * @param {number=} opt_height
 * @return {boolean} Whether the canvas was scaled.
 */
Runner.updateCanvasScaling = function(canvas, opt_width, opt_height) {
  const context =
      /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));

  // Query the various pixel ratios
  const devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;
  /** @suppress {missingProperties} */
  const backingStoreRatio =
      Math.floor(context.webkitBackingStorePixelRatio) || 1;
  const ratio = devicePixelRatio / backingStoreRatio;

  // Upscale the canvas if the two ratios don't match
  if (devicePixelRatio !== backingStoreRatio) {
    const oldWidth = opt_width || canvas.width;
    const oldHeight = opt_height || canvas.height;

    canvas.width = oldWidth * ratio;
    canvas.height = oldHeight * ratio;

    canvas.style.width = oldWidth + 'px';
    canvas.style.height = oldHeight + 'px';

    // Scale the context to counter the fact that we've manually scaled
    // our canvas element.
    context.scale(ratio, ratio);
    return true;
  } else if (devicePixelRatio === 1) {
    // Reset the canvas width / height. Fixes scaling bug when the page is
    // zoomed and the devicePixelRatio changes accordingly.
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';
  }
  return false;
};


/**
 * Get random number.
 * @param {number} min
 * @param {number} max
 */
function getRandomNum(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}


/**
 * Vibrate on mobile devices.
 * @param {number} duration Duration of the vibration in milliseconds.
 */
function vibrate(duration) {
  if (IS_MOBILE && window.navigator.vibrate) {
    window.navigator.vibrate(duration);
  }
}


/**
 * Create canvas element.
 * @param {Element} container Element to append canvas to.
 * @param {number} width
 * @param {number} height
 * @param {string=} opt_classname
 * @return {HTMLCanvasElement}
 */
function createCanvas(container, width, height, opt_classname) {
  const canvas =
      /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
  canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +
      opt_classname : Runner.classes.CANVAS;
  canvas.width = width;
  canvas.height = height;
  container.appendChild(canvas);

  return canvas;
}


/**
 * Decodes the base 64 audio to ArrayBuffer used by Web Audio.
 * @param {string} base64String
 */
function decodeBase64ToArrayBuffer(base64String) {
  const len = (base64String.length / 4) * 3;
  const str = atob(base64String);
  const arrayBuffer = new ArrayBuffer(len);
  const bytes = new Uint8Array(arrayBuffer);

  for (let i = 0; i < len; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes.buffer;
}


/**
 * Return the current timestamp.
 * @return {number}
 */
function getTimeStamp() {
  return IS_IOS ? new Date().getTime() : performance.now();
}


//******************************************************************************


/**
 * Game over panel.
 * @param {!HTMLCanvasElement} canvas
 * @param {Object} textImgPos
 * @param {Object} restartImgPos
 * @param {!Object} dimensions Canvas dimensions.
 * @constructor
 */
function GameOverPanel(canvas, textImgPos, restartImgPos, dimensions) {
  this.canvas = canvas;
  this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  this.canvasDimensions = dimensions;
  this.textImgPos = textImgPos;
  this.restartImgPos = restartImgPos;
  this.draw();
}


/**
 * Dimensions used in the panel.
 * @enum {number}
 */
GameOverPanel.dimensions = {
  TEXT_X: 0,
  TEXT_Y: 13,
  TEXT_WIDTH: 191,
  TEXT_HEIGHT: 11,
  RESTART_WIDTH: 36,
  RESTART_HEIGHT: 32
};


GameOverPanel.prototype = {
  /**
   * Update the panel dimensions.
   * @param {number} width New canvas width.
   * @param {number} opt_height Optional new canvas height.
   */
  updateDimensions(width, opt_height) {
    this.canvasDimensions.WIDTH = width;
    if (opt_height) {
      this.canvasDimensions.HEIGHT = opt_height;
    }
  },

  /**
   * Draw the panel.
   */
  draw() {
    const dimensions = GameOverPanel.dimensions;

    const centerX = this.canvasDimensions.WIDTH / 2;

    // Game over text.
    let textSourceX = dimensions.TEXT_X;
    let textSourceY = dimensions.TEXT_Y;
    let textSourceWidth = dimensions.TEXT_WIDTH;
    let textSourceHeight = dimensions.TEXT_HEIGHT;

    const textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));
    const textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);
    const textTargetWidth = dimensions.TEXT_WIDTH;
    const textTargetHeight = dimensions.TEXT_HEIGHT;

    let restartSourceWidth = dimensions.RESTART_WIDTH;
    let restartSourceHeight = dimensions.RESTART_HEIGHT;
    const restartTargetX = centerX - (dimensions.RESTART_WIDTH / 2);
    const restartTargetY = this.canvasDimensions.HEIGHT / 2;

    if (IS_HIDPI) {
      textSourceY *= 2;
      textSourceX *= 2;
      textSourceWidth *= 2;
      textSourceHeight *= 2;
      restartSourceWidth *= 2;
      restartSourceHeight *= 2;
    }

    textSourceX += this.textImgPos.x;
    textSourceY += this.textImgPos.y;

    // Game over text from sprite.
    this.canvasCtx.drawImage(Runner.imageSprite,
        textSourceX, textSourceY, textSourceWidth, textSourceHeight,
        textTargetX, textTargetY, textTargetWidth, textTargetHeight);

    // Restart button.
    this.canvasCtx.drawImage(Runner.imageSprite,
        this.restartImgPos.x, this.restartImgPos.y,
        restartSourceWidth, restartSourceHeight,
        restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,
        dimensions.RESTART_HEIGHT);
  }
};


//******************************************************************************

/**
 * Check for a collision.
 * @param {!Obstacle} obstacle
 * @param {!Trex} tRex T-rex object.
 * @param {CanvasRenderingContext2D=} opt_canvasCtx Optional canvas context for
 *    drawing collision boxes.
 * @return {Array<CollisionBox>|undefined}
 */
function checkForCollision(obstacle, tRex, opt_canvasCtx) {
  const obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;

  // Adjustments are made to the bounding box as there is a 1 pixel white
  // border around the t-rex and obstacles.
  const tRexBox = new CollisionBox(
      tRex.xPos + 1,
      tRex.yPos + 1,
      tRex.config.WIDTH - 2,
      tRex.config.HEIGHT - 2);

  const obstacleBox = new CollisionBox(
      obstacle.xPos + 1,
      obstacle.yPos + 1,
      obstacle.typeConfig.width * obstacle.size - 2,
      obstacle.typeConfig.height - 2);

  // Debug outer box
  if (opt_canvasCtx) {
    drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);
  }

  // Simple outer bounds check.
  if (boxCompare(tRexBox, obstacleBox)) {
    const collisionBoxes = obstacle.collisionBoxes;
    const tRexCollisionBoxes = tRex.ducking ?
        Trex.collisionBoxes.DUCKING : Trex.collisionBoxes.RUNNING;

    // Detailed axis aligned box check.
    for (let t = 0; t < tRexCollisionBoxes.length; t++) {
      for (let i = 0; i < collisionBoxes.length; i++) {
        // Adjust the box to actual positions.
        const adjTrexBox =
            createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);
        const adjObstacleBox =
            createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);
        const crashed = boxCompare(adjTrexBox, adjObstacleBox);

        // Draw boxes for debug.
        if (opt_canvasCtx) {
          drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);
        }

        if (crashed) {
          return [adjTrexBox, adjObstacleBox];
        }
      }
    }
  }
}


/**
 * Adjust the collision box.
 * @param {!CollisionBox} box The original box.
 * @param {!CollisionBox} adjustment Adjustment box.
 * @return {CollisionBox} The adjusted collision box object.
 */
function createAdjustedCollisionBox(box, adjustment) {
  return new CollisionBox(
      box.x + adjustment.x,
      box.y + adjustment.y,
      box.width,
      box.height);
}


/**
 * Draw the collision boxes for debug.
 */
function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {
  canvasCtx.save();
  canvasCtx.strokeStyle = '#f00';
  canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);

  canvasCtx.strokeStyle = '#0f0';
  canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,
      obstacleBox.width, obstacleBox.height);
  canvasCtx.restore();
}


/**
 * Compare two collision boxes for a collision.
 * @param {CollisionBox} tRexBox
 * @param {CollisionBox} obstacleBox
 * @return {boolean} Whether the boxes intersected.
 */
function boxCompare(tRexBox, obstacleBox) {
  let crashed = false;
  const tRexBoxX = tRexBox.x;
  const tRexBoxY = tRexBox.y;

  const obstacleBoxX = obstacleBox.x;
  const obstacleBoxY = obstacleBox.y;

  // Axis-Aligned Bounding Box method.
  if (tRexBox.x < obstacleBoxX + obstacleBox.width &&
      tRexBox.x + tRexBox.width > obstacleBoxX &&
      tRexBox.y < obstacleBox.y + obstacleBox.height &&
      tRexBox.height + tRexBox.y > obstacleBox.y) {
    crashed = true;
  }

  return crashed;
}


//******************************************************************************

/**
 * Collision box object.
 * @param {number} x X position.
 * @param {number} y Y Position.
 * @param {number} w Width.
 * @param {number} h Height.
 * @constructor
 */
function CollisionBox(x, y, w, h) {
  this.x = x;
  this.y = y;
  this.width = w;
  this.height = h;
}


//******************************************************************************

/**
 * Obstacle.
 * @param {CanvasRenderingContext2D} canvasCtx
 * @param {ObstacleType} type
 * @param {Object} spriteImgPos Obstacle position in sprite.
 * @param {Object} dimensions
 * @param {number} gapCoefficient Mutipler in determining the gap.
 * @param {number} speed
 * @param {number=} opt_xOffset
 * @constructor
 */
function Obstacle(canvasCtx, type, spriteImgPos, dimensions,
    gapCoefficient, speed, opt_xOffset) {

  this.canvasCtx = canvasCtx;
  this.spritePos = spriteImgPos;
  this.typeConfig = type;
  this.gapCoefficient = gapCoefficient;
  this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);
  this.dimensions = dimensions;
  this.remove = false;
  this.xPos = dimensions.WIDTH + (opt_xOffset || 0);
  this.yPos = 0;
  this.width = 0;
  this.collisionBoxes = [];
  this.gap = 0;
  this.speedOffset = 0;

  // For animated obstacles.
  this.currentFrame = 0;
  this.timer = 0;

  this.init(speed);
}

/**
 * Coefficient for calculating the maximum gap.
 * @const
 */
Obstacle.MAX_GAP_COEFFICIENT = 1.5;

/**
 * Maximum obstacle grouping count.
 * @const
 */
Obstacle.MAX_OBSTACLE_LENGTH = 3;


Obstacle.prototype = {
  /**
   * Initialise the DOM for the obstacle.
   * @param {number} speed
   */
  init(speed) {
    this.cloneCollisionBoxes();

    // Only allow sizing if we're at the right speed.
    if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {
      this.size = 1;
    }

    this.width = this.typeConfig.width * this.size;

    // Check if obstacle can be positioned at various heights.
    if (Array.isArray(this.typeConfig.yPos)) {
      const yPosConfig =
          IS_MOBILE ? this.typeConfig.yPosMobile : this.typeConfig.yPos;
      this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];
    } else {
      this.yPos = this.typeConfig.yPos;
    }

    this.draw();

    // Make collision box adjustments,
    // Central box is adjusted to the size as one box.
    //      ____        ______        ________
    //    _|   |-|    _|     |-|    _|       |-|
    //   | |<->| |   | |<--->| |   | |<----->| |
    //   | | 1 | |   | |  2  | |   | |   3   | |
    //   |_|___|_|   |_|_____|_|   |_|_______|_|
    //
    if (this.size > 1) {
      this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -
          this.collisionBoxes[2].width;
      this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
    }

    // For obstacles that go at a different speed from the horizon.
    if (this.typeConfig.speedOffset) {
      this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :
                                               -this.typeConfig.speedOffset;
    }

    this.gap = this.getGap(this.gapCoefficient, speed);
  },

  /**
   * Draw and crop based on size.
   */
  draw() {
    let sourceWidth = this.typeConfig.width;
    let sourceHeight = this.typeConfig.height;

    if (IS_HIDPI) {
      sourceWidth = sourceWidth * 2;
      sourceHeight = sourceHeight * 2;
    }

    // X position in sprite.
    let sourceX =
        (sourceWidth * this.size) * (0.5 * (this.size - 1)) + this.spritePos.x;

    // Animation frames.
    if (this.currentFrame > 0) {
      sourceX += sourceWidth * this.currentFrame;
    }

    this.canvasCtx.drawImage(
        Runner.imageSprite, sourceX, this.spritePos.y, sourceWidth * this.size,
        sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size,
        this.typeConfig.height);
  },

  /**
   * Obstacle frame update.
   * @param {number} deltaTime
   * @param {number} speed
   */
  update(deltaTime, speed) {
    if (!this.remove) {
      if (this.typeConfig.speedOffset) {
        speed += this.speedOffset;
      }
      this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);

      // Update frame
      if (this.typeConfig.numFrames) {
        this.timer += deltaTime;
        if (this.timer >= this.typeConfig.frameRate) {
          this.currentFrame =
              this.currentFrame === this.typeConfig.numFrames - 1 ?
              0 :
              this.currentFrame + 1;
          this.timer = 0;
        }
      }
      this.draw();

      if (!this.isVisible()) {
        this.remove = true;
      }
    }
  },

  /**
   * Calculate a random gap size.
   * - Minimum gap gets wider as speed increses
   * @param {number} gapCoefficient
   * @param {number} speed
   * @return {number} The gap size.
   */
  getGap(gapCoefficient, speed) {
    const minGap = Math.round(
        this.width * speed + this.typeConfig.minGap * gapCoefficient);
    const maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);
    return getRandomNum(minGap, maxGap);
  },

  /**
   * Check if obstacle is visible.
   * @return {boolean} Whether the obstacle is in the game area.
   */
  isVisible() {
    return this.xPos + this.width > 0;
  },

  /**
   * Make a copy of the collision boxes, since these will change based on
   * obstacle type and size.
   */
  cloneCollisionBoxes() {
    const collisionBoxes = this.typeConfig.collisionBoxes;

    for (let i = collisionBoxes.length - 1; i >= 0; i--) {
      this.collisionBoxes[i] = new CollisionBox(
          collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width,
          collisionBoxes[i].height);
    }
  }
};

/**
 * Obstacle definitions.
 * minGap: minimum pixel space betweeen obstacles.
 * multipleSpeed: Speed at which multiples are allowed.
 * speedOffset: speed faster / slower than the horizon.
 * minSpeed: Minimum speed which the obstacle can make an appearance.
 *
 * @typedef {{
 *   type: string,
 *   width: number,
 *   height: number,
 *   yPos: number,
 *   multipleSpeed: number,
 *   minGap: number,
 *   minSpeed: number,
 *   collisionBoxes: Array<CollisionBox>,
 * }}
 */
let ObstacleType;

/** @type {Array<ObstacleType>} */
Obstacle.types = [
  {
    type: 'CACTUS_SMALL',
    width: 17,
    height: 35,
    yPos: 105,
    multipleSpeed: 4,
    minGap: 120,
    minSpeed: 0,
    collisionBoxes: [
      new CollisionBox(0, 7, 5, 27),
      new CollisionBox(4, 0, 6, 34),
      new CollisionBox(10, 4, 7, 14)
    ]
  },
  {
    type: 'CACTUS_LARGE',
    width: 25,
    height: 50,
    yPos: 90,
    multipleSpeed: 7,
    minGap: 120,
    minSpeed: 0,
    collisionBoxes: [
      new CollisionBox(0, 12, 7, 38),
      new CollisionBox(8, 0, 7, 49),
      new CollisionBox(13, 10, 10, 38)
    ]
  },
  {
    type: 'PTERODACTYL',
    width: 46,
    height: 40,
    yPos: [ 100, 75, 50 ], // Variable height.
    yPosMobile: [ 100, 50 ], // Variable height mobile.
    multipleSpeed: 999,
    minSpeed: 8.5,
    minGap: 150,
    collisionBoxes: [
      new CollisionBox(15, 15, 16, 5),
      new CollisionBox(18, 21, 24, 6),
      new CollisionBox(2, 14, 4, 3),
      new CollisionBox(6, 10, 4, 7),
      new CollisionBox(10, 8, 6, 9)
    ],
    numFrames: 2,
    frameRate: 1000/6,
    speedOffset: .8
  }
];


//******************************************************************************
/**
 * T-rex game character.
 * @param {HTMLCanvasElement} canvas
 * @param {Object} spritePos Positioning within image sprite.
 * @constructor
 */
function Trex(canvas, spritePos) {
  this.canvas = canvas;
  this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  this.spritePos = spritePos;
  this.xPos = 0;
  this.yPos = 0;
  this.xInitialPos = 0;
  // Position when on the ground.
  this.groundYPos = 0;
  this.currentFrame = 0;
  this.currentAnimFrames = [];
  this.blinkDelay = 0;
  this.blinkCount = 0;
  this.animStartTime = 0;
  this.timer = 0;
  this.msPerFrame = 1000 / FPS;
  this.config = Trex.config;
  // Current status.
  this.status = Trex.status.WAITING;
  this.jumping = false;
  this.ducking = false;
  this.jumpVelocity = 0;
  this.reachedMinHeight = false;
  this.speedDrop = false;
  this.jumpCount = 0;
  this.jumpspotX = 0;

  this.init();
}


/**
 * T-rex player config.
 */
Trex.config = {
  DROP_VELOCITY: -5,
  GRAVITY: 0.6,
  HEIGHT: 47,
  HEIGHT_DUCK: 25,
  INIITAL_JUMP_VELOCITY: -10,
  INTRO_DURATION: 1500,
  MAX_JUMP_HEIGHT: 30,
  MIN_JUMP_HEIGHT: 30,
  SPEED_DROP_COEFFICIENT: 3,
  SPRITE_WIDTH: 262,
  START_X_POS: 50,
  WIDTH: 44,
  WIDTH_DUCK: 59
};


/**
 * Used in collision detection.
 * @enum {Array<CollisionBox>}
 */
Trex.collisionBoxes = {
  DUCKING: [
    new CollisionBox(1, 18, 55, 25)
  ],
  RUNNING: [
    new CollisionBox(22, 0, 17, 16),
    new CollisionBox(1, 18, 30, 9),
    new CollisionBox(10, 35, 14, 8),
    new CollisionBox(1, 24, 29, 5),
    new CollisionBox(5, 30, 21, 4),
    new CollisionBox(9, 34, 15, 4)
  ]
};


/**
 * Animation states.
 * @enum {string}
 */
Trex.status = {
  CRASHED: 'CRASHED',
  DUCKING: 'DUCKING',
  JUMPING: 'JUMPING',
  RUNNING: 'RUNNING',
  WAITING: 'WAITING'
};

/**
 * Blinking coefficient.
 * @const
 */
Trex.BLINK_TIMING = 7000;


/**
 * Animation config for different states.
 * @enum {Object}
 */
Trex.animFrames = {
  WAITING: {
    frames: [44, 0],
    msPerFrame: 1000 / 3
  },
  RUNNING: {
    frames: [88, 132],
    msPerFrame: 1000 / 12
  },
  CRASHED: {
    frames: [220],
    msPerFrame: 1000 / 60
  },
  JUMPING: {
    frames: [0],
    msPerFrame: 1000 / 60
  },
  DUCKING: {
    frames: [264, 323],
    msPerFrame: 1000 / 8
  }
};


Trex.prototype = {
  /**
   * T-rex player initaliser.
   * Sets the t-rex to blink at random intervals.
   */
  init() {
    this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
        Runner.config.BOTTOM_PAD;
    this.yPos = this.groundYPos;
    this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;

    this.draw(0, 0);
    this.update(0, Trex.status.WAITING);
  },

  /**
   * Setter for the jump velocity.
   * The approriate drop velocity is also set.
   * @param {number} setting
   */
  setJumpVelocity(setting) {
    this.config.INIITAL_JUMP_VELOCITY = -setting;
    this.config.DROP_VELOCITY = -setting / 2;
  },

  /**
   * Set the animation status.
   * @param {!number} deltaTime
   * @param {Trex.status=} opt_status Optional status to switch to.
   */
  update(deltaTime, opt_status) {
    this.timer += deltaTime;

    // Update the status.
    if (opt_status) {
      this.status = opt_status;
      this.currentFrame = 0;
      this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;
      this.currentAnimFrames = Trex.animFrames[opt_status].frames;

      if (opt_status === Trex.status.WAITING) {
        this.animStartTime = getTimeStamp();
        this.setBlinkDelay();
      }
    }

    // Game intro animation, T-rex moves in from the left.
    if (this.playingIntro && this.xPos < this.config.START_X_POS) {
      this.xPos += Math.round((this.config.START_X_POS /
          this.config.INTRO_DURATION) * deltaTime);
      this.xInitialPos = this.xPos;
    }

    if (this.status === Trex.status.WAITING) {
      this.blink(getTimeStamp());
    } else {
      this.draw(this.currentAnimFrames[this.currentFrame], 0);
    }

    // Update the frame position.
    if (this.timer >= this.msPerFrame) {
      this.currentFrame = this.currentFrame ==
          this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;
      this.timer = 0;
    }

    // Speed drop becomes duck if the down key is still being pressed.
    if (this.speedDrop && this.yPos === this.groundYPos) {
      this.speedDrop = false;
      this.setDuck(true);
    }
  },

  /**
   * Draw the t-rex to a particular position.
   * @param {number} x
   * @param {number} y
   */
  draw(x, y) {
    let sourceX = x;
    let sourceY = y;
    let sourceWidth = this.ducking && this.status !== Trex.status.CRASHED ?
        this.config.WIDTH_DUCK :
        this.config.WIDTH;
    let sourceHeight = this.config.HEIGHT;
    const outputHeight = sourceHeight;

    if (IS_HIDPI) {
      sourceX *= 2;
      sourceY *= 2;
      sourceWidth *= 2;
      sourceHeight *= 2;
    }

    // Adjustments for sprite sheet position.
    sourceX += this.spritePos.x;
    sourceY += this.spritePos.y;

    // Ducking.
    if (this.ducking && this.status !== Trex.status.CRASHED) {
      this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
          sourceWidth, sourceHeight,
          this.xPos, this.yPos,
          this.config.WIDTH_DUCK, outputHeight);
    } else {
      // Crashed whilst ducking. Trex is standing up so needs adjustment.
      if (this.ducking && this.status === Trex.status.CRASHED) {
        this.xPos++;
      }
      // Standing / running
      this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
          sourceWidth, sourceHeight,
          this.xPos, this.yPos,
          this.config.WIDTH, outputHeight);
    }
    this.canvasCtx.globalAlpha = 1;
  },

  /**
   * Sets a random time for the blink to happen.
   */
  setBlinkDelay() {
    this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);
  },

  /**
   * Make t-rex blink at random intervals.
   * @param {number} time Current time in milliseconds.
   */
  blink(time) {
    const deltaTime = time - this.animStartTime;

    if (deltaTime >= this.blinkDelay) {
      this.draw(this.currentAnimFrames[this.currentFrame], 0);

      if (this.currentFrame === 1) {
        // Set new random delay to blink.
        this.setBlinkDelay();
        this.animStartTime = time;
        this.blinkCount++;
      }
    }
  },

  /**
   * Initialise a jump.
   * @param {number} speed
   */
  startJump(speed) {
    if (!this.jumping) {
      this.update(0, Trex.status.JUMPING);
      // Tweak the jump velocity based on the speed.
      this.jumpVelocity = this.config.INIITAL_JUMP_VELOCITY - (speed / 10);
      this.jumping = true;
      this.reachedMinHeight = false;
      this.speedDrop = false;
    }
  },

  /**
   * Jump is complete, falling down.
   */
  endJump() {
    if (this.reachedMinHeight &&
        this.jumpVelocity < this.config.DROP_VELOCITY) {
      this.jumpVelocity = this.config.DROP_VELOCITY;
    }
  },

  /**
   * Update frame for a jump.
   * @param {number} deltaTime
   */
  updateJump(deltaTime) {
    const msPerFrame = Trex.animFrames[this.status].msPerFrame;
    const framesElapsed = deltaTime / msPerFrame;

    // Speed drop makes Trex fall faster.
    if (this.speedDrop) {
      this.yPos += Math.round(this.jumpVelocity *
          this.config.SPEED_DROP_COEFFICIENT * framesElapsed);
    } else {
      this.yPos += Math.round(this.jumpVelocity * framesElapsed);
    }

    this.jumpVelocity += this.config.GRAVITY * framesElapsed;

    // Minimum height has been reached.
    if (this.yPos < this.minJumpHeight || this.speedDrop) {
      this.reachedMinHeight = true;
    }

    // Reached max height
    if (this.yPos < this.config.MAX_JUMP_HEIGHT || this.speedDrop) {
      this.endJump();
    }

    // Back down at ground level. Jump completed.
    if (this.yPos > this.groundYPos) {
      this.reset();
      this.jumpCount++;
    }
  },

  /**
   * Set the speed drop. Immediately cancels the current jump.
   */
  setSpeedDrop() {
    this.speedDrop = true;
    this.jumpVelocity = 1;
  },

  /**
   * @param {boolean} isDucking
   */
  setDuck(isDucking) {
    if (isDucking && this.status !== Trex.status.DUCKING) {
      this.update(0, Trex.status.DUCKING);
      this.ducking = true;
    } else if (this.status === Trex.status.DUCKING) {
      this.update(0, Trex.status.RUNNING);
      this.ducking = false;
    }
  },

  /**
   * Reset the t-rex to running at start of game.
   */
  reset() {
    this.xPos = this.xInitialPos;
    this.yPos = this.groundYPos;
    this.jumpVelocity = 0;
    this.jumping = false;
    this.ducking = false;
    this.update(0, Trex.status.RUNNING);
    this.midair = false;
    this.speedDrop = false;
    this.jumpCount = 0;
  }
};


//******************************************************************************

/**
 * Handles displaying the distance meter.
 * @param {!HTMLCanvasElement} canvas
 * @param {Object} spritePos Image position in sprite.
 * @param {number} canvasWidth
 * @constructor
 */
function DistanceMeter(canvas, spritePos, canvasWidth) {
  this.canvas = canvas;
  this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  this.image = Runner.imageSprite;
  this.spritePos = spritePos;
  this.x = 0;
  this.y = 5;

  this.currentDistance = 0;
  this.maxScore = 0;
  this.highScore = '0';
  this.container = null;

  this.digits = [];
  this.achievement = false;
  this.defaultString = '';
  this.flashTimer = 0;
  this.flashIterations = 0;
  this.invertTrigger = false;
  this.flashingRafId = null;
  this.highScoreBounds = {};
  this.highScoreFlashing = false;

  this.config = DistanceMeter.config;
  this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;
  this.init(canvasWidth);
}


/**
 * @enum {number}
 */
DistanceMeter.dimensions = {
  WIDTH: 10,
  HEIGHT: 13,
  DEST_WIDTH: 11
};


/**
 * Y positioning of the digits in the sprite sheet.
 * X position is always 0.
 * @type {Array<number>}
 */
DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];


/**
 * Distance meter config.
 * @enum {number}
 */
DistanceMeter.config = {
  // Number of digits.
  MAX_DISTANCE_UNITS: 5,

  // Distance that causes achievement animation.
  ACHIEVEMENT_DISTANCE: 100,

  // Used for conversion from pixel distance to a scaled unit.
  COEFFICIENT: 0.025,

  // Flash duration in milliseconds.
  FLASH_DURATION: 1000 / 4,

  // Flash iterations for achievement animation.
  FLASH_ITERATIONS: 3,

  // Padding around the high score hit area.
  HIGH_SCORE_HIT_AREA_PADDING: 4
};


DistanceMeter.prototype = {
  /**
   * Initialise the distance meter to '00000'.
   * @param {number} width Canvas width in px.
   */
  init(width) {
    let maxDistanceStr = '';

    this.calcXPos(width);
    this.maxScore = this.maxScoreUnits;
    for (let i = 0; i < this.maxScoreUnits; i++) {
      this.draw(i, 0);
      this.defaultString += '0';
      maxDistanceStr += '9';
    }

    this.maxScore = parseInt(maxDistanceStr, 10);
  },

  /**
   * Calculate the xPos in the canvas.
   * @param {number} canvasWidth
   */
  calcXPos(canvasWidth) {
    this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *
        (this.maxScoreUnits + 1));
  },

  /**
   * Draw a digit to canvas.
   * @param {number} digitPos Position of the digit.
   * @param {number} value Digit value 0-9.
   * @param {boolean=} opt_highScore Whether drawing the high score.
   */
  draw(digitPos, value, opt_highScore) {
    let sourceWidth = DistanceMeter.dimensions.WIDTH;
    let sourceHeight = DistanceMeter.dimensions.HEIGHT;
    let sourceX = DistanceMeter.dimensions.WIDTH * value;
    let sourceY = 0;

    const targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;
    const targetY = this.y;
    const targetWidth = DistanceMeter.dimensions.WIDTH;
    const targetHeight = DistanceMeter.dimensions.HEIGHT;

    // For high DPI we 2x source values.
    if (IS_HIDPI) {
      sourceWidth *= 2;
      sourceHeight *= 2;
      sourceX *= 2;
    }

    sourceX += this.spritePos.x;
    sourceY += this.spritePos.y;

    this.canvasCtx.save();

    if (opt_highScore) {
      // Left of the current score.
      const highScoreX = this.x - (this.maxScoreUnits * 2) *
          DistanceMeter.dimensions.WIDTH;
      this.canvasCtx.translate(highScoreX, this.y);
    } else {
      this.canvasCtx.translate(this.x, this.y);
    }

    this.canvasCtx.drawImage(this.image, sourceX, sourceY,
        sourceWidth, sourceHeight,
        targetX, targetY,
        targetWidth, targetHeight
      );

    this.canvasCtx.restore();
  },

  /**
   * Covert pixel distance to a 'real' distance.
   * @param {number} distance Pixel distance ran.
   * @return {number} The 'real' distance ran.
   */
  getActualDistance(distance) {
    return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;
  },

  /**
   * Update the distance meter.
   * @param {number} distance
   * @param {number} deltaTime
   * @return {boolean} Whether the acheivement sound fx should be played.
   */
  update(deltaTime, distance) {
    let paint = true;
    let playSound = false;

    if (!this.achievement) {
      distance = this.getActualDistance(distance);
      // Score has gone beyond the initial digit count.
      if (distance > this.maxScore && this.maxScoreUnits ==
        this.config.MAX_DISTANCE_UNITS) {
        this.maxScoreUnits++;
        this.maxScore = parseInt(this.maxScore + '9', 10);
      } else {
        this.distance = 0;
      }

      if (distance > 0) {
        // Achievement unlocked.
        if (distance % this.config.ACHIEVEMENT_DISTANCE === 0) {
          // Flash score and play sound.
          this.achievement = true;
          this.flashTimer = 0;
          playSound = true;
        }

        // Create a string representation of the distance with leading 0.
        const distanceStr = (this.defaultString +
            distance).substr(-this.maxScoreUnits);
        this.digits = distanceStr.split('');
      } else {
        this.digits = this.defaultString.split('');
      }
    } else {
      // Control flashing of the score on reaching acheivement.
      if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
        this.flashTimer += deltaTime;

        if (this.flashTimer < this.config.FLASH_DURATION) {
          paint = false;
        } else if (this.flashTimer >
            this.config.FLASH_DURATION * 2) {
          this.flashTimer = 0;
          this.flashIterations++;
        }
      } else {
        this.achievement = false;
        this.flashIterations = 0;
        this.flashTimer = 0;
      }
    }

    // Draw the digits if not flashing.
    if (paint) {
      for (let i = this.digits.length - 1; i >= 0; i--) {
        this.draw(i, parseInt(this.digits[i], 10));
      }
    }

    this.drawHighScore();
    return playSound;
  },

  /**
   * Draw the high score.
   */
  drawHighScore() {
    this.canvasCtx.save();
    this.canvasCtx.globalAlpha = .8;
    for (let i = this.highScore.length - 1; i >= 0; i--) {
      this.draw(i, parseInt(this.highScore[i], 10), true);
    }
    this.canvasCtx.restore();
  },

  /**
   * Set the highscore as a array string.
   * Position of char in the sprite: H - 10, I - 11.
   * @param {number} distance Distance ran in pixels.
   */
  setHighScore(distance) {
    distance = this.getActualDistance(distance);
    const highScoreStr = (this.defaultString +
        distance).substr(-this.maxScoreUnits);

    this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));
  },


  /**
   * Whether a clicked is in the high score area.
   * @param {Event} e Event object.
   * @return {boolean} Whether the click was in the high score bounds.
   */
  hasClickedOnHighScore(e) {
    let x = 0;
    let y = 0;

    if (e.touches) {
      // Bounds for touch differ from pointer.
      const canvasBounds = this.canvas.getBoundingClientRect();
      x = e.touches[0].clientX - canvasBounds.left;
      y = e.touches[0].clientY - canvasBounds.top;
    } else {
      x = e.offsetX;
      y = e.offsetY;
    }

    this.highScoreBounds = this.getHighScoreBounds();
    return x >= this.highScoreBounds.x && x <=
        this.highScoreBounds.x + this.highScoreBounds.width &&
        y >= this.highScoreBounds.y && y <=
        this.highScoreBounds.y + this.highScoreBounds.height;
  },

  /**
   * Get the bounding box for the high score.
   * @return {Object} Object with x, y, width and height properties.
   */
  getHighScoreBounds() {
    return {
      x: (this.x - (this.maxScoreUnits * 2) *
          DistanceMeter.dimensions.WIDTH) -
          DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
      y: this.y,
      width: DistanceMeter.dimensions.WIDTH * (this.highScore.length + 1) +
          DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
      height: DistanceMeter.dimensions.HEIGHT +
          (DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING * 2)
    };
  },

  /**
   * Animate flashing the high score to indicate ready for resetting.
   * The flashing stops following this.config.FLASH_ITERATIONS x 2 flashes.
   */
  flashHighScore() {
    const now = getTimeStamp();
    const deltaTime = now - (this.frameTimeStamp || now);
    let paint = true;
    this.frameTimeStamp = now;

    // Reached the max number of flashes.
    if (this.flashIterations > this.config.FLASH_ITERATIONS * 2) {
      this.cancelHighScoreFlashing();
      return;
    }

    this.flashTimer += deltaTime;

    if (this.flashTimer < this.config.FLASH_DURATION) {
      paint = false;
    } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
      this.flashTimer = 0;
      this.flashIterations++;
    }

    if (paint) {
      this.drawHighScore();
    } else {
      this.clearHighScoreBounds();
    }
    // Frame update.
    this.flashingRafId =
        requestAnimationFrame(this.flashHighScore.bind(this));
  },

  /**
   * Draw empty rectangle over high score.
   */
  clearHighScoreBounds() {
    this.canvasCtx.save();
    this.canvasCtx.fillStyle = '#fff';
    this.canvasCtx.rect(this.highScoreBounds.x, this.highScoreBounds.y,
        this.highScoreBounds.width, this.highScoreBounds.height);
    this.canvasCtx.fill();
    this.canvasCtx.restore();
  },

  /**
   * Starts the flashing of the high score.
   */
  startHighScoreFlashing() {
    this.highScoreFlashing = true;
    this.flashHighScore();
  },

  /**
   * Whether high score is flashing.
   * @return {boolean}
   */
  isHighScoreFlashing() {
    return this.highScoreFlashing;
  },

  /**
   * Stop flashing the high score.
   */
  cancelHighScoreFlashing() {
    if (this.flashingRafId) {
      cancelAnimationFrame(this.flashingRafId);
    }
    this.flashIterations = 0;
    this.flashTimer = 0;
    this.highScoreFlashing = false;
    this.clearHighScoreBounds();
    this.drawHighScore();
  },

  /**
   * Clear the high score.
   */
  resetHighScore() {
    this.setHighScore(0);
    this.cancelHighScoreFlashing();
  },

  /**
   * Reset the distance meter back to '00000'.
   */
  reset() {
    this.update(0, 0);
    this.achievement = false;
  }
};


//******************************************************************************

/**
 * Cloud background item.
 * Similar to an obstacle object but without collision boxes.
 * @param {HTMLCanvasElement} canvas Canvas element.
 * @param {Object} spritePos Position of image in sprite.
 * @param {number} containerWidth
 * @constructor
 */
function Cloud(canvas, spritePos, containerWidth) {
  this.canvas = canvas;
  this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
  this.spritePos = spritePos;
  this.containerWidth = containerWidth;
  this.xPos = containerWidth;
  this.yPos = 0;
  this.remove = false;
  this.cloudGap = getRandomNum(Cloud.config.MIN_CLOUD_GAP,
      Cloud.config.MAX_CLOUD_GAP);

  this.init();
}


/**
 * Cloud object config.
 * @enum {number}
 */
Cloud.config = {
  HEIGHT: 14,
  MAX_CLOUD_GAP: 400,
  MAX_SKY_LEVEL: 30,
  MIN_CLOUD_GAP: 100,
  MIN_SKY_LEVEL: 71,
  WIDTH: 46
};


Cloud.prototype = {
  /**
   * Initialise the cloud. Sets the Cloud height.
   */
  init() {
    this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,
        Cloud.config.MIN_SKY_LEVEL);
    this.draw();
  },

  /**
   * Draw the cloud.
   */
  draw() {
    this.canvasCtx.save();
    let sourceWidth = Cloud.config.WIDTH;
    let sourceHeight = Cloud.config.HEIGHT;
    const outputWidth = sourceWidth;
    const outputHeight = sourceHeight;
    if (IS_HIDPI) {
      sourceWidth = sourceWidth * 2;
      sourceHeight = sourceHeight * 2;
    }

    this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,
        this.spritePos.y,
        sourceWidth, sourceHeight,
        this.xPos, this.yPos,
        outputWidth, outputHeight);

    this.canvasCtx.restore();
  },

  /**
   * Update the cloud position.
   * @param {number} speed
   */
  update(speed) {
    if (!this.remove) {
      this.xPos -= Math.ceil(speed);
      this.draw();

      // Mark as removeable if no longer in the canvas.
      if (!this.isVisible()) {
        this.remove = true;
      }
    }
  },

  /**
   * Check if the cloud is visible on the stage.
   * @return {boolean}
   */
  isVisible() {
    return this.xPos + Cloud.config.WIDTH > 0;
  }
};


//******************************************************************************

/**
 * Nightmode shows a moon and stars on the horizon.
 * @param {HTMLCanvasElement} canvas
 * @param {number} spritePos
 * @param {number} containerWidth
 * @constructor
 */
function NightMode(canvas, spritePos, containerWidth) {
  this.spritePos = spritePos;
  this.canvas = canvas;
  this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  this.xPos = containerWidth - 50;
  this.yPos = 30;
  this.currentPhase = 0;
  this.opacity = 0;
  this.containerWidth = containerWidth;
  this.stars = [];
  this.drawStars = false;
  this.placeStars();
}

/**
 * @enum {number}
 */
NightMode.config = {
  FADE_SPEED: 0.035,
  HEIGHT: 40,
  MOON_SPEED: 0.25,
  NUM_STARS: 2,
  STAR_SIZE: 9,
  STAR_SPEED: 0.3,
  STAR_MAX_Y: 70,
  WIDTH: 20
};

NightMode.phases = [140, 120, 100, 60, 40, 20, 0];

NightMode.prototype = {
  /**
   * Update moving moon, changing phases.
   * @param {boolean} activated Whether night mode is activated.
   */
  update(activated) {
    // Moon phase.
    if (activated && this.opacity === 0) {
      this.currentPhase++;

      if (this.currentPhase >= NightMode.phases.length) {
        this.currentPhase = 0;
      }
    }

    // Fade in / out.
    if (activated && (this.opacity < 1 || this.opacity === 0)) {
      this.opacity += NightMode.config.FADE_SPEED;
    } else if (this.opacity > 0) {
      this.opacity -= NightMode.config.FADE_SPEED;
    }

    // Set moon positioning.
    if (this.opacity > 0) {
      this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);

      // Update stars.
      if (this.drawStars) {
        for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
          this.stars[i].x =
              this.updateXPos(this.stars[i].x, NightMode.config.STAR_SPEED);
        }
      }
      this.draw();
    } else {
      this.opacity = 0;
      this.placeStars();
    }
    this.drawStars = true;
  },

  updateXPos(currentPos, speed) {
    if (currentPos < -NightMode.config.WIDTH) {
      currentPos = this.containerWidth;
    } else {
      currentPos -= speed;
    }
    return currentPos;
  },

  draw() {
    let moonSourceWidth = this.currentPhase === 3 ? NightMode.config.WIDTH * 2 :
                                                    NightMode.config.WIDTH;
    let moonSourceHeight = NightMode.config.HEIGHT;
    let moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];
    const moonOutputWidth = moonSourceWidth;
    let starSize = NightMode.config.STAR_SIZE;
    let starSourceX = Runner.spriteDefinition.LDPI.STAR.x;

    if (IS_HIDPI) {
      moonSourceWidth *= 2;
      moonSourceHeight *= 2;
      moonSourceX = this.spritePos.x +
          (NightMode.phases[this.currentPhase] * 2);
      starSize *= 2;
      starSourceX = Runner.spriteDefinition.HDPI.STAR.x;
    }

    this.canvasCtx.save();
    this.canvasCtx.globalAlpha = this.opacity;

    // Stars.
    if (this.drawStars) {
      for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
        this.canvasCtx.drawImage(Runner.imageSprite,
            starSourceX, this.stars[i].sourceY, starSize, starSize,
            Math.round(this.stars[i].x), this.stars[i].y,
            NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);
      }
    }

    // Moon.
    this.canvasCtx.drawImage(Runner.imageSprite, moonSourceX,
        this.spritePos.y, moonSourceWidth, moonSourceHeight,
        Math.round(this.xPos), this.yPos,
        moonOutputWidth, NightMode.config.HEIGHT);

    this.canvasCtx.globalAlpha = 1;
    this.canvasCtx.restore();
  },

  // Do star placement.
  placeStars() {
    const segmentSize = Math.round(this.containerWidth /
        NightMode.config.NUM_STARS);

    for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
      this.stars[i] = {};
      this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));
      this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);

      if (IS_HIDPI) {
        this.stars[i].sourceY = Runner.spriteDefinition.HDPI.STAR.y +
            NightMode.config.STAR_SIZE * 2 * i;
      } else {
        this.stars[i].sourceY = Runner.spriteDefinition.LDPI.STAR.y +
            NightMode.config.STAR_SIZE * i;
      }
    }
  },

  reset() {
    this.currentPhase = 0;
    this.opacity = 0;
    this.update(false);
  }

};


//******************************************************************************

/**
 * Horizon Line.
 * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.
 * @param {HTMLCanvasElement} canvas
 * @param {Object} spritePos Horizon position in sprite.
 * @constructor
 */
function HorizonLine(canvas, spritePos) {
  this.spritePos = spritePos;
  this.canvas = canvas;
  this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  this.sourceDimensions = {};
  this.dimensions = HorizonLine.dimensions;
  this.sourceXPos = [this.spritePos.x, this.spritePos.x +
      this.dimensions.WIDTH];
  this.xPos = [];
  this.yPos = 0;
  this.bumpThreshold = 0.5;

  this.setSourceDimensions();
  this.draw();
}


/**
 * Horizon line dimensions.
 * @enum {number}
 */
HorizonLine.dimensions = {
  WIDTH: 600,
  HEIGHT: 12,
  YPOS: 127
};


HorizonLine.prototype = {
  /**
   * Set the source dimensions of the horizon line.
   */
  setSourceDimensions() {
    for (const dimension in HorizonLine.dimensions) {
      if (IS_HIDPI) {
        if (dimension !== 'YPOS') {
          this.sourceDimensions[dimension] =
              HorizonLine.dimensions[dimension] * 2;
        }
      } else {
        this.sourceDimensions[dimension] =
            HorizonLine.dimensions[dimension];
      }
      this.dimensions[dimension] = HorizonLine.dimensions[dimension];
    }

    this.xPos = [0, HorizonLine.dimensions.WIDTH];
    this.yPos = HorizonLine.dimensions.YPOS;
  },

  /**
   * Return the crop x position of a type.
   */
  getRandomType() {
    return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;
  },

  /**
   * Draw the horizon line.
   */
  draw() {
    this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],
        this.spritePos.y,
        this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
        this.xPos[0], this.yPos,
        this.dimensions.WIDTH, this.dimensions.HEIGHT);

    this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],
        this.spritePos.y,
        this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
        this.xPos[1], this.yPos,
        this.dimensions.WIDTH, this.dimensions.HEIGHT);
  },

  /**
   * Update the x position of an indivdual piece of the line.
   * @param {number} pos Line position.
   * @param {number} increment
   */
  updateXPos(pos, increment) {
    const line1 = pos;
    const line2 = pos === 0 ? 1 : 0;

    this.xPos[line1] -= increment;
    this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;

    if (this.xPos[line1] <= -this.dimensions.WIDTH) {
      this.xPos[line1] += this.dimensions.WIDTH * 2;
      this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;
      this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;
    }
  },

  /**
   * Update the horizon line.
   * @param {number} deltaTime
   * @param {number} speed
   */
  update(deltaTime, speed) {
    const increment = Math.floor(speed * (FPS / 1000) * deltaTime);

    if (this.xPos[0] <= 0) {
      this.updateXPos(0, increment);
    } else {
      this.updateXPos(1, increment);
    }
    this.draw();
  },

  /**
   * Reset horizon to the starting position.
   */
  reset() {
    this.xPos[0] = 0;
    this.xPos[1] = HorizonLine.dimensions.WIDTH;
  }
};


//******************************************************************************

/**
 * Horizon background class.
 * @param {HTMLCanvasElement} canvas
 * @param {Object} spritePos Sprite positioning.
 * @param {Object} dimensions Canvas dimensions.
 * @param {number} gapCoefficient
 * @constructor
 */
function Horizon(canvas, spritePos, dimensions, gapCoefficient) {
  this.canvas = canvas;
  this.canvasCtx =
      /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
  this.config = Horizon.config;
  this.dimensions = dimensions;
  this.gapCoefficient = gapCoefficient;
  this.obstacles = [];
  this.obstacleHistory = [];
  this.horizonOffsets = [0, 0];
  this.cloudFrequency = this.config.CLOUD_FREQUENCY;
  this.spritePos = spritePos;
  this.nightMode = null;

  // Cloud
  this.clouds = [];
  this.cloudSpeed = this.config.BG_CLOUD_SPEED;

  // Horizon
  this.horizonLine = null;
  this.init();
}


/**
 * Horizon config.
 * @enum {number}
 */
Horizon.config = {
  BG_CLOUD_SPEED: 0.2,
  BUMPY_THRESHOLD: .3,
  CLOUD_FREQUENCY: .5,
  HORIZON_HEIGHT: 16,
  MAX_CLOUDS: 6
};


Horizon.prototype = {
  /**
   * Initialise the horizon. Just add the line and a cloud. No obstacles.
   */
  init() {
    this.addCloud();
    this.horizonLine = new HorizonLine(this.canvas, this.spritePos.HORIZON);
    this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,
        this.dimensions.WIDTH);
  },

  /**
   * @param {number} deltaTime
   * @param {number} currentSpeed
   * @param {boolean} updateObstacles Used as an override to prevent
   *     the obstacles from being updated / added. This happens in the
   *     ease in section.
   * @param {boolean} showNightMode Night mode activated.
   */
  update(deltaTime, currentSpeed, updateObstacles, showNightMode) {
    this.runningTime += deltaTime;
    this.horizonLine.update(deltaTime, currentSpeed);
    this.nightMode.update(showNightMode);
    this.updateClouds(deltaTime, currentSpeed);

    if (updateObstacles) {
      this.updateObstacles(deltaTime, currentSpeed);
    }
  },

  /**
   * Update the cloud positions.
   * @param {number} deltaTime
   * @param {number} speed
   */
  updateClouds(deltaTime, speed) {
    const cloudSpeed = this.cloudSpeed / 1000 * deltaTime * speed;
    const numClouds = this.clouds.length;

    if (numClouds) {
      for (let i = numClouds - 1; i >= 0; i--) {
        this.clouds[i].update(cloudSpeed);
      }

      const lastCloud = this.clouds[numClouds - 1];

      // Check for adding a new cloud.
      if (numClouds < this.config.MAX_CLOUDS &&
          (this.dimensions.WIDTH - lastCloud.xPos) > lastCloud.cloudGap &&
          this.cloudFrequency > Math.random()) {
        this.addCloud();
      }

      // Remove expired clouds.
      this.clouds = this.clouds.filter(function(obj) {
        return !obj.remove;
      });
    } else {
      this.addCloud();
    }
  },

  /**
   * Update the obstacle positions.
   * @param {number} deltaTime
   * @param {number} currentSpeed
   */
  updateObstacles(deltaTime, currentSpeed) {
    // Obstacles, move to Horizon layer.
    const updatedObstacles = this.obstacles.slice(0);

    for (let i = 0; i < this.obstacles.length; i++) {
      const obstacle = this.obstacles[i];
      obstacle.update(deltaTime, currentSpeed);

      // Clean up existing obstacles.
      if (obstacle.remove) {
        updatedObstacles.shift();
      }
    }
    this.obstacles = updatedObstacles;

    if (this.obstacles.length > 0) {
      const lastObstacle = this.obstacles[this.obstacles.length - 1];

      if (lastObstacle && !lastObstacle.followingObstacleCreated &&
          lastObstacle.isVisible() &&
          (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <
          this.dimensions.WIDTH) {
        this.addNewObstacle(currentSpeed);
        lastObstacle.followingObstacleCreated = true;
      }
    } else {
      // Create new obstacles.
      this.addNewObstacle(currentSpeed);
    }
  },

  removeFirstObstacle() {
    this.obstacles.shift();
  },

  /**
   * Add a new obstacle.
   * @param {number} currentSpeed
   */
  addNewObstacle(currentSpeed) {
    const obstacleTypeIndex = getRandomNum(0, Obstacle.types.length - 1);
    const obstacleType = Obstacle.types[obstacleTypeIndex];

    // Check for multiples of the same type of obstacle.
    // Also check obstacle is available at current speed.
    if (this.duplicateObstacleCheck(obstacleType.type) ||
        currentSpeed < obstacleType.minSpeed) {
      this.addNewObstacle(currentSpeed);
    } else {
      const obstacleSpritePos = this.spritePos[obstacleType.type];

      this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType,
          obstacleSpritePos, this.dimensions,
          this.gapCoefficient, currentSpeed, obstacleType.width));

      this.obstacleHistory.unshift(obstacleType.type);

      if (this.obstacleHistory.length > 1) {
        this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);
      }
    }
  },

  /**
   * Returns whether the previous two obstacles are the same as the next one.
   * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.
   * @return {boolean}
   */
  duplicateObstacleCheck(nextObstacleType) {
    let duplicateCount = 0;

    for (let i = 0; i < this.obstacleHistory.length; i++) {
      duplicateCount =
          this.obstacleHistory[i] === nextObstacleType ? duplicateCount + 1 : 0;
    }
    return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;
  },

  /**
   * Reset the horizon layer.
   * Remove existing obstacles and reposition the horizon line.
   */
  reset() {
    this.obstacles = [];
    this.horizonLine.reset();
    this.nightMode.reset();
  },

  /**
   * Update the canvas width and scaling.
   * @param {number} width Canvas width.
   * @param {number} height Canvas height.
   */
  resize(width, height) {
    this.canvas.width = width;
    this.canvas.height = height;
  },

  /**
   * Add a new cloud to the horizon.
   */
  addCloud() {
    this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,
        this.dimensions.WIDTH));
  }
};
</script>
</head>
<body id="t" style="font-family: system-ui, sans-serif; font-size: 75%" jstcache="0" class="neterror">
  <div id="main-frame-error" class="interstitial-wrapper" jstcache="0">
    <div id="main-content" jstcache="0">
      <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" alt="" jstcache="1"></div>
      <div id="main-message" jstcache="0">
        <h1 jstcache="0">
          <span jsselect="heading" jsvalues=".innerHTML:msg" jstcache="10"><span jscontent="hostName" jstcache="23">2542116.fls.doubleclick.net</span> is blocked</span>
          <a id="error-information-button" class="hidden" onclick="toggleErrorInformationPopup();" jstcache="0"></a>
        </h1>
        <p jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">Requests to the server have been blocked by an extension.</p>
        <!--The suggestion list and error code are normally presented inline,
          in which case error-information-popup-* divs have no effect. When
          error-information-popup-container has the use-popup-container class, this
          information is provided in a popup instead.-->
        <div id="error-information-popup-container" jstcache="0">
          <div id="error-information-popup" jstcache="0">
            <div id="error-information-popup-box" jstcache="0">
              <div id="error-information-popup-content" jstcache="0">
                <div id="suggestions-list" style="" jsdisplay="(suggestionsSummaryList &amp;&amp; suggestionsSummaryList.length)" jstcache="17">
                  <p jsvalues=".innerHTML:suggestionsSummaryListHeader" jstcache="19"></p>
                  <ul jsvalues=".className:suggestionsSummaryList.length == 1 ? &#39;single-suggestion&#39; : &#39;&#39;" jstcache="20" class="single-suggestion">
                    <li jsselect="suggestionsSummaryList" jsvalues=".innerHTML:summary" jstcache="22" jsinstance="*0">Try disabling your extensions.</li>
                  </ul>
                </div>
                <div class="error-code" jscontent="errorCode" jstcache="18">ERR_BLOCKED_BY_CLIENT</div>
                <p id="error-information-popup-close" jstcache="0">
                  <a class="link-button" jscontent="closeDescriptionPopup" onclick="toggleErrorInformationPopup();" jstcache="21">null</a>
                </p>
              </div>
            </div>
          </div>
        </div>
        <div id="diagnose-frame" class="hidden" jstcache="0"></div>
        <div id="download-links-wrapper" class="hidden" jstcache="0">
          <div id="download-link-wrapper" jstcache="0">
            <a id="download-link" class="link-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
            </a>
          </div>
          <div id="download-link-clicked-wrapper" class="hidden" jstcache="0">
            <div id="download-link-clicked" class="link-button" jsselect="downloadButton" jscontent="disabledMsg" jstcache="12" style="display: none;">
            </div>
          </div>
        </div>
        <div id="save-page-for-later-button" class="hidden" jstcache="0">
          <a class="link-button" onclick="savePageLaterClick()" jsselect="savePageLater" jscontent="savePageMsg" jstcache="11" style="display: none;">
          </a>
        </div>
        <div id="cancel-save-page-button" class="hidden" onclick="cancelSavePageClick()" jsselect="savePageLater" jsvalues=".innerHTML:cancelMsg" jstcache="5" style="display: none;">
        </div>
        <div id="offline-content-list" class="list-hidden" hidden="" jstcache="0">
          <div id="offline-content-list-visibility-card" onclick="toggleOfflineContentListVisibility(true)" jstcache="0">
            <div id="offline-content-list-title" jsselect="offlineContentList" jscontent="title" jstcache="13" style="display: none;">
            </div>
            <div jstcache="0">
              <div id="offline-content-list-show-text" jsselect="offlineContentList" jscontent="showText" jstcache="15" style="display: none;">
              </div>
              <div id="offline-content-list-hide-text" jsselect="offlineContentList" jscontent="hideText" jstcache="16" style="display: none;">
              </div>
            </div>
          </div>
          <div id="offline-content-suggestions" jstcache="0"></div>
          <div id="offline-content-list-action" jstcache="0">
            <a class="link-button" onclick="launchDownloadsPage()" jsselect="offlineContentList" jscontent="actionText" jstcache="14" style="display: none;">
            </a>
          </div>
        </div>
      </div>
    </div>
    <div id="buttons" class="nav-wrapper suggested-right" jstcache="0">
      <div id="control-buttons" jstcache="0">
        <button id="reload-button" class="blue-button text-button" onclick="reloadButtonClick(this.url);" jsselect="reloadButton" jsvalues=".url:reloadUrl" jscontent="msg" jstcache="6">Reload</button>
        <button id="download-button" class="blue-button text-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="7" style="display: none;">
        </button>
      </div>
      <button id="details-button" class="secondary-button text-button small-link" onclick="detailsButtonClick(); toggleHelpBox()" jscontent="details" jsdisplay="(suggestionsDetails &amp;&amp; suggestionsDetails.length &gt; 0) || diagnose" jsvalues=".detailsText:details; .hideDetailsText:hideDetails;" jstcache="3" style="display: none;"></button>
    </div>
    <div id="details" class="hidden" jstcache="0">
      <div class="suggestions" jsselect="suggestionsDetails" jstcache="4" jsinstance="*0" style="display: none;">
        <div class="suggestion-header" jsvalues=".innerHTML:header" jstcache="8"></div>
        <div class="suggestion-body" jsvalues=".innerHTML:body" jstcache="9"></div>
      </div>
    </div>
  </div>
  <div id="sub-frame-error" jstcache="0">
    <!-- Show details when hovering over the icon, in case the details are
         hidden because they're too large. -->
    <div class="icon icon-generic" jseval="updateIconClass(this.classList, iconClass)" jstcache="1"></div>
    <div id="sub-frame-error-details" jsselect="summary" jsvalues=".innerHTML:msg" jstcache="2">Requests to the server have been blocked by an extension.</div>
  </div>

  <div id="offline-resources" jstcache="0">
    <img id="offline-resources-1x" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABMUAAABBCAMAAADmHuOOAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozNDhmYjcyNS1lZDRkLTRkNGEtOGU4ZS0zZDZlNWJiNWMyNGQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0UwMzg1RUMwMDJCMTFFNkI1NTVBNjZDNEFGRENEQTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0UwMzg1RUIwMDJCMTFFNkI1NTVBNjZDNEFGRENEQTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0MjA5Yjk0Yi00MTA4LTRmZjUtOTVmNi02MWU3Y2E5YWU1MzUiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo4MGM3MDBjYi00ODhiLTExNzktYjg3YS1jODZiYTFiOGU1ODgiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz73qFqWAAADAFBMVEVYWFjPb2/Dw8P86elISEj+/v762tp0c3PT09NoaGiK2KGXDg774+OU26rcKSmr47y8vLz19fW96cqMNDT++Pj/UlLy+/WgHBzhNTXJ7dTstrY0NDSZ3a3U8dzr6+vIyMilpaX+d3f5lZXB6s751NREwGn1w8PN9P/x8fHKysrt7e39/f1Kwm+ul5f99fWsS0tQMzOqqqrn19f2y8vVR0eNeHj/g4OysrLyu7vlxMTkOTnum5vhS0vGKirzsrLsi4tqMzPk9um15sRxSkqx5cGUk5OLi4vjWlr+bGz2/Pij4LV50pRRxHSD1ZzY8uDxrKw6Ojri4uJLw2+MUlKbm5v98fHiU1PFMzPl5eXd9OTeOjrd3d3RMjLmQkLspKTshITsk5NcyX3xoqLz29v16enkKSnla2vYVVXXiopjy4OkNTX+zMzlNTX4Tk7hY2PbycnY2Ni2NDT39/ec3rDpdXX5/fqCgoJtzot10ZH10dHpNDTra2vXnJzsfHzdMTH24uLVq6u5JCT/+/sqKirOzs7vqKitYmLaubn8w8Pb9//t+fHEp6fHtLSqICDg9eficHDd0tLFm5tz0I/i+f/5/fy3oqJHwWzq+O6458bkgIDienrEgYHgRUVAv2ZZx3oqMzNPUFDqODjo6OjzODhdYGD8/v779PS7sbHYMjLw4uJIwm3/Xl7niYnirq69Wlr77u77/vxVxnfOw8MVJSXkoaHoZmbKHx/oXFzsRER/YWHgQEDoUlKl4bhCwGhvz4yZgYHQ79mgoKDomZn9rKzYNDRozYaP2aUwLy+g37P/u7vn9+zBRkbo+v8+vmTjj4/nS0t91JczOztAMjL28fETHBzlRkb/oqLfLy98fX1AQUH/tbXl4ODTPT3g2tpRRETb8+L5+vqur6+Oj4+Hh4fJzMy66Mj5+flJwm23t7fnMjL6+vr7+/u05sNMw2+u5L7Jycnu6Oinra1fyX+/v7/wVVXxW1vo6+vPy8v8+vrLyMjK0NDd9OOXl5feNDRMw3D///8fPj6GAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAAKM1JREFUeNrsnQtcE1e6wNOYCaAYiWCMjgKthAZiKYi7UAWE+kAE5FF5GLAqKq00SyGCVaxYQLddW7S1XdBqMVK0bl/ottaK1Uqvitfutkrbxdx2l+sLaeLqXdl7b393TeaeM5PHzCQ5mfASNN+vNeHMN2fOTOb85/u+850zPCJp7BQncoros2C/exTKmxjhFrc8GFKdxflux8L8OFfrN6J6KJxb9VC61Dxim8zoRE72F8QAxt56yw0ytzwYFAuetZ6rrnfBTK4cCysoC+bc7/ywATu34CF0qXtPMe9gb85HefNRq/zurXtwmlhSEuZ6gZNKD0nKbQvLb627MMWeNrkBs78h2f6GOesujHXpNiyfk5w8drg/JnT8uXO75dR3z4jAzfDTP2ru3Ah/8EUc0HrFsjU0IqJbQX5cpr4BRZ+7VxaJCYIfCIouB94GRbkRc+dGwX2Jkta5rXkEoYiKiFIT4suB5C78wEDxAJyF36YVWcJsbhhr3rTpl1kbOakeWL9+U+QPXAmiCN7IGTZhkZFc7Su/lSuyvBOD7weKEUHbIzke5K1HGXIPutkamSyZDiVspEw28hC9/1+QyUbT95DskMkWMOqQjFmTQP+7847MaMOr/anwii2wbQG1YY0dwJIbztnZMNLuHii2kXtMGuYU86gBwlPDr4FtNTXzwOfldFim9SQIL/ilRhNq1tQAAvWQZQLIom4cfGvLBfc1WVbjRRAhOLlvBkG0wi9tUUSXtqbNn8jDqV2aar7/cSCsFe+vphfHZAu56GZFFk/fXsnJGjsQuT3nmZYYTsCp3rSieUXiKxzbS/gVFGZxhOOIT6cXZ8cE3QcUCyPiYsK4HeRPTIr9bj8H3L/iyln4vYKR9rOj7dvgaTxJ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" jstcache="0">
    <img id="offline-resources-2x" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACYkAAACCCAMAAAA+cCW9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTExIDc5LjE1ODMyNSwgMjAxNS8wOS8xMC0wMToxMDoyMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozNDhmYjcyNS1lZDRkLTRkNGEtOGU4ZS0zZDZlNWJiNWMyNGQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6REVEMDNFMjcwMDJBMTFFNkI1NTVBNjZDNEFGRENEQTkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6REVEMDNFMjYwMDJBMTFFNkI1NTVBNjZDNEFGRENEQTkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0MjA5Yjk0Yi00MTA4LTRmZjUtOTVmNi02MWU3Y2E5YWU1MzUiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo4MGM3MDBjYi00ODhiLTExNzktYjg3YS1jODZiYTFiOGU1ODgiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7nkeIzAAADAFBMVEX86uqFhIT8/PzoqanDw8O15sRpaWnZSEjgNTX75OR50pTptbXmysrc8+Pt7e31ycn4NDRrMjLh+f/l5eX5mJh5eXlUMjLz+/bHKyujo6Pq1taXGRmK2KH51tbaFxf/UlI0NDT6+vrqeXmjHh7zw8P73d3p6en/iIj98fH++Piub2+T26lRxXTzu7usrKzbV1fUMjLK7dW5JSWpISHaZmaB1ZrrhIT99fX39/f12dnwoqLtlJTe3t6qTEzVdnbW9v/YiYnGNDTA6s3z0tIyMjK2NDT19fXxra3JyclCQkK0goLti4vtm5uTk5P5zc3iOjrdOjpszoniXFybnJzN9P/W1tblamr0/f//eHinMjLiY2Pz8/NdXV3gTk5jyoLNzc06OTnx8PAWMjLcMzPR0dHkNjZOTk6UZWXy8vK9vb3mQkLi4eH/aGjSmpq5ubnKrKzZqKiDMzOEBARycnL//PyXMzPk9unrOTmt473zs7NUVFSys7OYBQXdKyvGcnLmKCjsNDQkJSXZ2dnYMjL5/v3AZ2dvAwPKiIjiVFT46OglMzPcIyPr4eHhcnLq+O7bNDTqbW3V8d36w8ORTEzmjIyj4LXayMjpc3P34OBNw3HZvr7+u7vigoLER0flfHz7q6vQLi6/ra2/np787u7gkpKHIyNAMjL1TEyg37OVKCj/s7PoW1vE69DsRkauCQn89PT/XV0SFBRdyX73/fm/v79Vxne/WVnjmpqLERHoYmLhMDBrS0vfQUEyTU3JtLT/oKDQICC+ERHUOzvM7tfoVVU1MjLgRUWptLT/VlZcAQGhFRWHkpLf9OYzAACa3a9YQ0P7/v+qGxvv5+flSEizvb1Yx3n9/f348vL7+PjP79lwz4zc3NzoMjJ00JBozYdHR0fn9+zoTk5KXFz5+/svLi7////+/v7//f3+//7+///p7+/OxcXd4uLw9fWn4rnU0ND4HR3yUFC3trbsWFjj09ONjY1PamrDubmjrKzO0tLQ1dWXl5ekkJDeNDRMw3D///9tlcWXAAABAHRSTlP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AU/cHJQAASMxJREFUeNrsnQ9AFNe972FEHEiySLb8CyK7gAQqIILiCsQEHZbdiEo0kBBAWJelCEkaIogazVUwiX+qq2lStTWGWy1Jqqlp/BOl3NtcE7yp11rTXLcxGk1bdo33T957ucm777103Td/9s/M7szs/F1m4Xzb4O4w85szZw5zPvM7v/M7Ea7xpMv3PurVg4+5gICAgICAgIAUrQj0vzsSSBEX89ijFN1rB/cXCAgIaByp+3B+dWlOuJjNnVFWt28GuGuyVTAgMeWRmB+IoSh2G9xgICAgoPGknJczhjMiwsVsTPWfnU1p4K7JVsGAxBRGYgEg9uijD6L/vxeMUgIBAQGNI71stsaFj9ky56ZSiU12H86qLt0O7hsgMaEk1h2RVVZ6WIYrufzgowwCrrFwVtKbj+TlPfJqUrgfEYorB5JHpiWNRmNbQq3f5tUJkahM5A1t6H7RBb4t7QXYJmNbpP+xJuzYhNXub7W4JVzebcQvIhuxwxuJk6yOpMhzZlNKo7ERLZ+BfGBCG6olnl3w/VPwj2rKmYmLSFCH2y2JcTpnhI/ZpbDzZalt5sSVDO+Lkdpq9+GXq0tjwu6+ARIT4BPLXbpvU5n0V3Lvo4y61zExbuaJV1fmrbzE1nPvnvlu3o11bNVxz9wreZ/PZjvLsc9PXZl7jzjGuIQW9KsTXHY9doVoYKeOcTWuzCP4KxTnAOKiFI1b0ZTNkcRGL4mt1nhV68Et36ZGE+XgRorBFN9+5JOkGD0biYNJ5jAVUMqByugBKlOjZxNBXy7iC6mY3rMkkE0pXsfjJh1ZsODIpPtcJc4mxZuNeGbB6ddeO73gLtc2p1mG2ohz9udLX8VLS4b37A+P+wZITOToZFz/2VsSX4jjURbdOzG8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" jstcache="0">
    <template id="audio-resources" jstcache="0"></template>
  </div>


<script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 *
 * Note that loadTimeData is not guaranteed to be consistent between page
 * refreshes (https://crbug.com/740629) and should not contain values that might
 * change if the page is re-opened later.
 */

// #import {assert} from './assert.m.js';
// #import {parseHtmlSubset} from './parse_html_subset.m.js';

/**
 * @typedef {{
 *   substitutions: (!Array<string>|undefined),
 *   attrs: (!Array<string>|undefined),
 *   tags: (!Array<string>|undefined),
 * }}
 */
/* #export */ let SanitizeInnerHtmlOpts;

// eslint-disable-next-line no-var
/* #export */ /** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData(){}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      const value = this.data_[id];
      expect(typeof value !== 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF(id, var_args) {
      const value = this.getString(id);
      if (!value) {
        return '';
      }

      const args = Array.prototype.slice.call(arguments);
      args[0] = value;
      return this.substituteString.apply(this, args);
    },

    /**
     * Make a string safe for use with with Polymer bindings that are
     * inner-h-t-m-l (or other innerHTML use).
     * @param {string} rawString The unsanitized string.
     * @param {SanitizeInnerHtmlOpts=} opts Optional additional allowed tags and
     *     attributes.
     * @return {string}
     */
    sanitizeInnerHtml(rawString, opts) {
      opts = opts || {};
      return parseHtmlSubset('<b>' + rawString + '</b>', opts.tags, opts.attrs)
          .firstChild.innerHTML;
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument. Any standalone $ signs must be escaped as
     * $$.
     * @param {string} label The label to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    substituteString(label, var_args) {
      const varArgs = arguments;
      return label.replace(/\$(.|$|\n)/g, function(m) {
        assert(m.match(/\$[$1-9]/), 'Unescaped $ found in localized string.');
        return m === '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * Returns a formatted string where $1 to $9 are replaced by the second to
     * tenth argument, split apart into a list of pieces describing how the
     * substitution was performed. Any standalone $ signs must be escaped as $$.
     * @param {string} label A localized string to substitute through.
     *     This is not an resource ID.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {!Array<!{value: string, arg: (null|string)}>} The formatted
     *     string pieces.
     */
    getSubstitutedStringPieces(label, var_args) {
      const varArgs = arguments;
      // Split the string by separately matching all occurrences of $1-9 and of
      // non $1-9 pieces.
      const pieces = (label.match(/(\$[1-9])|(([^$]|\$([^1-9]|$))+)/g) ||
                      []).map(function(p) {
        // Pieces that are not $1-9 should be returned after replacing $$
        // with $.
        if (!p.match(/^\$[1-9]$/)) {
          assert(
              (p.match(/\$/g) || []).length % 2 === 0,
              'Unescaped $ found in localized string.');
          return {value: p.replace(/\$\$/g, '$'), arg: null};
        }

        // Otherwise, return the substitution value.
        return {value: varArgs[p[1]], arg: p};
      });

      return pieces;
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger(id) {
      const value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value === Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues(replacements) {
      expect(
          typeof replacements === 'object',
          'Replacements must be a dictionary object.');
      for (const key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error(
          'Unexpected condition on ' + document.location.href + ': ' + message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(
        typeof value === type, '[' + value + '] (' + id + ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;

  // Expose |loadTimeData| directly on |window|. This is only necessary by the
  // auto-generated load_time_data.m.js, since within a JS module the scope is
  // local.
  window.loadTimeData = loadTimeData;
})();
</script><script jstcache="0">loadTimeData.data = {"details":"Details","errorCode":"ERR_BLOCKED_BY_CLIENT","fontfamily":"system-ui, sans-serif","fontsize":"75%","heading":{"hostName":"2542116.fls.doubleclick.net","msg":"\u003Cspan jscontent=\"hostName\">\u003C/span> is blocked"},"hideDetails":"Hide details","iconClass":"icon-generic","language":"en","reloadButton":{"msg":"Reload","reloadUrl":"https://2542116.fls.doubleclick.net/activityi;src=2542116;type=gblog;cat=googl0;ord=ord=5057217187511.643?"},"suggestionsDetails":[],"suggestionsSummaryList":[{"summary":"Try disabling your extensions."}],"summary":{"failedUrl":"https://2542116.fls.doubleclick.net/activityi;src=2542116;type=gblog;cat=googl0;ord=ord=5057217187511.643?","hostName":"2542116.fls.doubleclick.net","msg":"Requests to the server have been blocked by an extension."},"textdirection":"ltr","title":"2542116.fls.doubleclick.net"};</script><script jstcache="0">// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file serves as a proxy to bring the included js file from /third_party
// into its correct location under the resources directory tree, whence it is
// delivered via a chrome://resources URL.  See ../webui_resources.grd.

// Note: this <include> is not behind a single-line comment because the first
// line of the file is source code (so the first line would be skipped) instead
// of a licence header.
// clang-format off
(function(){function l(a,b,c){return Function.prototype.call.apply(Array.prototype.slice,arguments)}function m(a,b,c){var e=l(arguments,2);return function(){return b.apply(a,e)}}function n(a,b){var c=new p(b);for(c.h=[a];c.h.length;){var e=c,d=c.h.shift();e.i(d);for(d=d.firstChild;d;d=d.nextSibling)1==d.nodeType&&e.h.push(d)}}function p(a){this.i=a}function q(a){a.style.display=""}function r(a){a.style.display="none"};var t=/\s*;\s*/;function u(a,b){this.l.apply(this,arguments)}u.prototype.l=function(a,b){this.a||(this.a={});if(b){var c=this.a,e=b.a;for(d in e)c[d]=e[d]}else{var d=this.a;e=v;for(c in e)d[c]=e[c]}this.a.$this=a;this.a.$context=this;this.f="undefined"!=typeof a&&null!=a?a:"";b||(this.a.$top=this.f)};var v={$default:null},w=[];function x(a){for(var b in a.a)delete a.a[b];a.f=null;w.push(a)}function y(a,b,c){try{return b.call(c,a.a,a.f)}catch(e){return v.$default}}
u.prototype.clone=function(a,b,c){if(0<w.length){var e=w.pop();u.call(e,a,this);a=e}else a=new u(a,this);a.a.$index=b;a.a.$count=c;return a};var z;window.trustedTypes&&(z=trustedTypes.createPolicy("jstemplate",{createScript:function(a){return a}}));var A={};function B(a){if(!A[a])try{var b="(function(a_, b_) { with (a_) with (b_) return "+a+" })",c=window.trustedTypes?z.createScript(b):b;A[a]=window.eval(c)}catch(e){}return A[a]}
function E(a){var b=[];a=a.split(t);for(var c=0,e=a.length;c<e;++c){var d=a[c].indexOf(":");if(!(0>d)){var g=a[c].substr(0,d).replace(/^\s+/,"").replace(/\s+$/,"");d=B(a[c].substr(d+1));b.push(g,d)}}return b};function F(){}var G=0,H={0:{}},I={},J={},K=[];function L(a){a.__jstcache||n(a,function(b){M(b)})}var N=[["jsselect",B],["jsdisplay",B],["jsvalues",E],["jsvars",E],["jseval",function(a){var b=[];a=a.split(t);for(var c=0,e=a.length;c<e;++c)if(a[c]){var d=B(a[c]);b.push(d)}return b}],["transclude",function(a){return a}],["jscontent",B],["jsskip",B]];
function M(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");if(null!=b)return a.__jstcache=H[b];b=K.length=0;for(var c=N.length;b<c;++b){var e=N[b][0],d=a.getAttribute(e);J[e]=d;null!=d&&K.push(e+"="+d)}if(0==K.length)return a.setAttribute("jstcache","0"),a.__jstcache=H[0];var g=K.join("&");if(b=I[g])return a.setAttribute("jstcache",b),a.__jstcache=H[b];var h={};b=0;for(c=N.length;b<c;++b){d=N[b];e=d[0];var f=d[1];d=J[e];null!=d&&(h[e]=f(d))}b=""+ ++G;a.setAttribute("jstcache",
b);H[b]=h;I[g]=b;return a.__jstcache=h}function P(a,b){a.j.push(b);a.o.push(0)}function Q(a){return a.c.length?a.c.pop():[]}
F.prototype.g=function(a,b){var c=R(b),e=c.transclude;if(e)(c=S(e))?(b.parentNode.replaceChild(c,b),e=Q(this),e.push(this.g,a,c),P(this,e)):b.parentNode.removeChild(b);else if(c=c.jsselect){c=y(a,c,b);var d=b.getAttribute("jsinstance");var g=!1;d&&("*"==d.charAt(0)?(d=parseInt(d.substr(1),10),g=!0):d=parseInt(d,10));var h=null!=c&&"object"==typeof c&&"number"==typeof c.length;e=h?c.length:1;var f=h&&0==e;if(h)if(f)d?b.parentNode.removeChild(b):(b.setAttribute("jsinstance","*0"),r(b));else if(q(b),
null===d||""===d||g&&d<e-1){g=Q(this);d=d||0;for(h=e-1;d<h;++d){var k=b.cloneNode(!0);b.parentNode.insertBefore(k,b);T(k,c,d);f=a.clone(c[d],d,e);g.push(this.b,f,k,x,f,null)}T(b,c,d);f=a.clone(c[d],d,e);g.push(this.b,f,b,x,f,null);P(this,g)}else d<e?(g=c[d],T(b,c,d),f=a.clone(g,d,e),g=Q(this),g.push(this.b,f,b,x,f,null),P(this,g)):b.parentNode.removeChild(b);else null==c?r(b):(q(b),f=a.clone(c,0,1),g=Q(this),g.push(this.b,f,b,x,f,null),P(this,g))}else this.b(a,b)};
F.prototype.b=function(a,b){var c=R(b),e=c.jsdisplay;if(e){if(!y(a,e,b)){r(b);return}q(b)}if(e=c.jsvars)for(var d=0,g=e.length;d<g;d+=2){var h=e[d],f=y(a,e[d+1],b);a.a[h]=f}if(e=c.jsvalues)for(d=0,g=e.length;d<g;d+=2)if(f=e[d],h=y(a,e[d+1],b),"$"==f.charAt(0))a.a[f]=h;else if("."==f.charAt(0)){f=f.substr(1).split(".");for(var k=b,O=f.length,C=0,U=O-1;C<U;++C){var D=f[C];k[D]||(k[D]={});k=k[D]}k[f[O-1]]=h}else f&&("boolean"==typeof h?h?b.setAttribute(f,f):b.removeAttribute(f):b.setAttribute(f,""+h));
if(e=c.jseval)for(d=0,g=e.length;d<g;++d)y(a,e[d],b);e=c.jsskip;if(!e||!y(a,e,b))if(c=c.jscontent){if(c=""+y(a,c,b),b.innerHTML!=c){for(;b.firstChild;)e=b.firstChild,e.parentNode.removeChild(e);b.appendChild(this.m.createTextNode(c))}}else{c=Q(this);for(e=b.firstChild;e;e=e.nextSibling)1==e.nodeType&&c.push(this.g,a,e);c.length&&P(this,c)}};function R(a){if(a.__jstcache)return a.__jstcache;var b=a.getAttribute("jstcache");return b?a.__jstcache=H[b]:M(a)}
function S(a,b){var c=document;if(b){var e=c.getElementById(a);if(!e){e=b();var d=c.getElementById("jsts");d||(d=c.createElement("div"),d.id="jsts",r(d),d.style.position="absolute",c.body.appendChild(d));var g=c.createElement("div");d.appendChild(g);g.innerHTML=e;e=c.getElementById(a)}c=e}else c=c.getElementById(a);return c?(L(c),c=c.cloneNode(!0),c.removeAttribute("id"),c):null}function T(a,b,c){c==b.length-1?a.setAttribute("jsinstance","*"+c):a.setAttribute("jsinstance",""+c)};window.jstGetTemplate=S;window.JsEvalContext=u;window.jstProcess=function(a,b){var c=new F;L(b);c.m=b?9==b.nodeType?b:b.ownerDocument||document:document;var e=m(c,c.g,a,b),d=c.j=[],g=c.o=[];c.c=[];e();for(var h,f,k;d.length;)h=d[d.length-1],e=g[g.length-1],e>=h.length?(e=c,f=d.pop(),f.length=0,e.c.push(f),g.pop()):(f=h[e++],k=h[e++],h=h[e++],g[g.length-1]=e,f.call(c,k,h))};
})()
</script><script jstcache="0">var tp = document.getElementById('t');jstProcess(loadTimeData.createJsEvalContext(), tp);</script></body></html>